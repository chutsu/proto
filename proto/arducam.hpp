#ifndef ARDUCAM_HPP
#define ARDUCAM_HPP

#include <iostream>
#include <string>
#include <thread>
#include <unistd.h>

#include <opencv2/opencv.hpp>
#include <ArduCamLib.h>

#ifndef timestamp_t
typedef int64_t timestamp_t;
#endif

struct timespec tic() {
  struct timespec time_start;
  clock_gettime(CLOCK_MONOTONIC, &time_start);
  return time_start;
}

float toc(struct timespec *tic) {
  struct timespec toc;
  float time_elasped;

  clock_gettime(CLOCK_MONOTONIC, &toc);
  time_elasped = (toc.tv_sec - tic->tv_sec);
  time_elasped += (toc.tv_nsec - tic->tv_nsec) / 1000000000.0;

  return time_elasped;
}

timestamp_t time_now() {
  struct timespec spec;
  clock_gettime(CLOCK_REALTIME, &spec);

  const time_t sec = spec.tv_sec;
  const long int ns = spec.tv_nsec;
  const uint64_t BILLION = 1000000000L;

  return (uint64_t) sec * BILLION + (uint64_t) ns;
}

double ts2sec(const timestamp_t ts) {
  return ts * 1e-9;
}

namespace ArduCam {

// MACROS
/**
 * Log info
 * @param[in] M Message
 * @param[in] ... Varadic arguments
 */
#ifndef ARDUCAM_INFO
#define ARDUCAM_INFO(...)                                                      \
  do {                                                                         \
    fprintf(stderr, "[INFO] [%s:%d:%s()]: ", __FILE__, __LINE__, __func__);    \
    fprintf(stderr, __VA_ARGS__);                                              \
  } while (0)
#endif

/**
 * Log error
 * @param[in] M Message
 * @param[in] ... Varadic arguments
 */
#ifndef ARDUCAM_ERROR
#define ARDUCAM_ERROR(...)                                                     \
  do {                                                                         \
    fprintf(stderr, "[ERROR] [%s:%d:%s()]: ", __FILE__, __LINE__, __func__);   \
    fprintf(stderr, __VA_ARGS__);                                              \
  } while (0)
#endif

/**
 * Fatal
 *
 * @param[in] M Message
 * @param[in] ... Varadic arguments
 */
#ifndef ARDUCAM_FATAL
#define ARDUCAM_FATAL(...)                                                     \
  do {                                                                         \
    fprintf(stderr, "[FATAL] [%s:%d:%s()]: ", __FILE__, __LINE__, __func__);   \
    fprintf(stderr, __VA_ARGS__);                                              \
  } while (0);                                                                 \
  exit(-1)
#endif

std::string cvtype2str(const int type) {
  std::string r;

  uchar depth = type & CV_MAT_DEPTH_MASK;
  uchar chans = 1 + (type >> CV_CN_SHIFT);

  switch ( depth ) {
    case CV_8U:  r = "8U"; break;
    case CV_8S:  r = "8S"; break;
    case CV_16U: r = "16U"; break;
    case CV_16S: r = "16S"; break;
    case CV_32S: r = "32S"; break;
    case CV_32F: r = "32F"; break;
    case CV_64F: r = "64F"; break;
    default:     r = "User"; break;
  }

  r += "C";
  r += (chans+'0');

  return r;
}

int list_cameras() {
  ArduCamIndexinfo infos[16];
  const int num_cameras = ArduCam_scan(infos);
  if (num_cameras == 0) {
    return 0;
  }

  for (int i = 0; i < num_cameras; i++) {
    unsigned char *buf = infos[i].u8SerialNum;

    std::ostringstream os;
    os << buf[0] << buf[1] << buf[2] << buf[3] << "-";
    os << buf[4] << buf[5] << buf[6] << buf[7] << "-";
    os << buf[8] << buf[9] << buf[10] << buf[11];
    const auto serial = os.str();

    const auto cam_idx = infos[i].u8UsbIndex;
    printf("Camera Index:%4d\tSerial: %s\n", cam_idx, serial.c_str());
  }

  // Need to sleep 2 seconds atleast or else for some strange reason
  // ArduCameras would not initialize after this call
  sleep(2);

  return num_cameras;
}

class MT9V034C {
protected:
  bool opened_ = false;
  size_t frame_index_ = 0;
  struct timespec last_frame_time_ = {};
  float fps_ = 0.0f;

  int index_;
  int img_w_;
  int img_h_;
  std::string serial_;
  ArduCamHandle handle_;

public:
  MT9V034C() = delete;
  MT9V034C(const MT9V034C &) = delete;

  MT9V034C(const int index = 0, const int img_w = 640, const int img_h = 480)
      : index_{index}, img_w_{img_w}, img_h_{img_h} {
  }

  virtual ~MT9V034C() {
    if (opened_) {
      ArduCam_close(handle_);
      opened_ = false;
    }
  }

  ArduCamHandle handle() {
    return handle_;
  }

  bool opened() {
    return opened_;
  }

  size_t frameIndex() {
    return frame_index_;
  }

  float fps() {
    return fps_;
  }

  int index() {
    return index_;
  }

  int imageWidth() {
    return img_w_;
  }

  int imageHeight() {
    return img_h_;
  }

  std::string serial() {
    return serial_;
  }

  int open() {
    // Set camera configuration
    ArduCamCfg cfg = {};
    cfg.u32Width = img_w_;
    cfg.u32Height = img_h_;
    cfg.emI2cMode = I2C_MODE_8_16;
    cfg.emImageFmtMode = FORMAT_MODE_RAW;
    cfg.u32I2cAddr = 0x90; // I2C address of camera
    cfg.u8PixelBits = 10;  // Bit width of the image generated by camera
    cfg.u8PixelBytes = 2;  // Number of bytes per pixel
    cfg.u32TransLvl = 0;

    // Open camera
    int ret_val = ArduCam_open(handle_, &cfg, index_);
    if (ret_val != USB_CAMERA_NO_ERROR) {
      return -1;
    }

    // Read camera serial number
    unsigned char buf[16];
    ArduCam_readUserData(handle_, 0x400 - 16, 16, buf);
    std::ostringstream os;
    os << buf[0] << buf[1] << buf[2] << buf[3] << "-";
    os << buf[4] << buf[5] << buf[6] << buf[7] << "-";
    os << buf[8] << buf[9] << buf[10] << buf[11];
    serial_ = os.str();

    // Set USB-Shield configurations
    // VRCMD = 0xD7, 0x4600, 0x0100, 1, 0x85
    // VRCMD = 0xD7, 0x4600, 0x0200, 1, 0x00
    // VRCMD = 0xD7, 0x4600, 0x0300, 1, 0xC0
    // VRCMD = 0xD7, 0x4600, 0x0300, 1, 0x40
    // VRCMD = 0xD7, 0x4600, 0x0400, 1, 0x00
    // VRCMD = 0xD7, 0x4600, 0x0A00, 1, 0x02
    // VRCMD = 0xF6, 0x0000, 0x0000, 3, 0x03, 0x04, 0x0C
    uint8_t cmd = 0xD7;
    uint8_t buf_all[7][3] = {{0x85}, {0x00}, {0xC0}, {0x40}, {0x00}, {0x02}};
    uint8_t buf_usb2[3] = {0x03, 0x04, 0x0C};
    ArduCam_setboardConfig(handle_, cmd, 0x4600, 0x0100, 1, buf_all[0]);
    ArduCam_setboardConfig(handle_, cmd, 0x4600, 0x0200, 1, buf_all[1]);
    ArduCam_setboardConfig(handle_, cmd, 0x4600, 0x0300, 1, buf_all[2]);
    ArduCam_setboardConfig(handle_, cmd, 0x4600, 0x0300, 1, buf_all[3]);
    ArduCam_setboardConfig(handle_, cmd, 0x4600, 0x0400, 1, buf_all[4]);
    ArduCam_setboardConfig(handle_, cmd, 0x4600, 0x0A00, 1, buf_all[5]);
    ArduCam_setboardConfig(handle_, cmd, 0, 0, 3, buf_usb2);

    // Set MT9V034C camera configurations
    ArduCam_writeSensorReg(handle_, 0x03, img_h_);
    ArduCam_writeSensorReg(handle_, 0x04, img_w_);
    ArduCam_writeSensorReg(handle_, 0x0D, 0x320);
    ArduCam_writeSensorReg(handle_, 0x07, 0x398);

    // Set Hardware-trigger mode
    int retval = ArduCam_setMode(handle_, EXTERNAL_TRIGGER_MODE);
    if (retval == USB_BOARD_FW_VERSION_NOT_SUPPORT_ERROR) {
      ARDUCAM_ERROR("USB-Shield does support [EXTERNAL_TRIGGER_MODE]!\n");
      return -1;
    }

    // Update flag
    opened_ = true;

    return 0;
  }

  int update(cv::Mat &image, timestamp_t &ts) {
    const auto retval = ArduCam_isFrameReady(handle_);
    if (retval != 1) {
      return -1;
    }

    ArduCamOutData *frame = NULL;
    ts = time_now();
    if (ArduCam_getSingleFrame(handle_, frame, 1000) != USB_CAMERA_NO_ERROR) {
      return -1;
    }

    const auto bytes = frame->pu8ImageData;
    const auto bit_width = frame->stImagePara.u8PixelBits;
    image = cv::Mat(img_h_, img_w_, CV_8UC1);
    unsigned char *tmp = (unsigned char *) malloc(img_w_ * img_h_);
    int idx = 0;
    for (int i = 0; i < img_w_ * img_h_ * 2; i += 2) {
      tmp[idx++] = ((bytes[i + 1] << 8 | bytes[i]) >> (bit_width - 8)) & 0xFF;
    }
    memcpy(image.data, tmp, img_w_ * img_h_);
    free(tmp);

    cv::cvtColor(image, image, cv::COLOR_BayerRG2BGR);

    if (frame_index_ != 0) {
      const auto time = toc(&last_frame_time_);
      fps_ = 1.0 / time;
    }
    last_frame_time_ = tic();
    frame_index_++;

    return 0;
  }
};

} // namespace ArduCam

#endif // ARDUCAM_HPP

//////////////////////////////////////////////////////////////////////////////
//                             IMPLEMENTATION                               //
//////////////////////////////////////////////////////////////////////////////

#ifdef ARDUCAM_IMPLEMENTATION

int main(int argc, char **argv) {
  const auto num_cameras = ArduCam::list_cameras();

  // Initialize cameras
  std::vector<std::shared_ptr<ArduCam::MT9V034C>> cameras;
  for (int cam_idx = 0; cam_idx < num_cameras; cam_idx++) {
    cameras.emplace_back(std::make_shared<ArduCam::MT9V034C>(cam_idx));
    cameras[cam_idx]->open();
  }

  // Initialize images
  const int img_w = cameras[0]->imageWidth();
  const int img_h = cameras[0]->imageHeight();
  std::vector<cv::Mat> cam_frames;
  std::map<int, timestamp_t> cam_ts;
  for (int cam_idx = 0; cam_idx < num_cameras; cam_idx++) {
    cam_frames.push_back(cv::Mat::zeros(img_h, img_w, CV_8UC3));
    cam_ts[cam_idx] = 0;
  }

  // int frame_idx = 0;
  // timestamp_t last_ts = -1;
  // while (true) {
  //   // Grab frames from camera
  //   for (int cam_idx = 0; cam_idx < num_cameras; cam_idx++) {
  //     cv::Mat image;
  //     timestamp_t ts = 0;
  //     if (cameras[cam_idx]->update(image, ts) == 0) {
  //       cam_frames[cam_idx] = image;
  //       cam_ts[cam_idx] = ts;
  //     }
  //   }

  //   // Check timestamps
  //   const auto timestamps_ok = fabs(ts2sec(cam_ts[0]) - ts2sec(cam_ts[1])) <= 0.1;
  //   if (timestamps_ok && cam_ts[0] != last_ts) {
  //     cv::Mat viz = cam_frames[0];
  //     for (size_t i = 1; i < cam_frames.size(); i++) {
  //       cv::hconcat(viz, cam_frames[i], viz);
  //     }

  //     printf("frame: %d\n", frame_idx);
  //     printf("cam0 ts: %ld\n", cam_ts[0]);
  //     printf("cam1 ts: %ld\n", cam_ts[1]);
  //     printf("last ts: %ld\n", last_ts);
  //     printf("diff ts: %f\n", fabs(ts2sec(cam_ts[0]) - ts2sec(cam_ts[1])));
  //     printf("\n");

  //     // printf("fps: %f\n", cameras[0]->fps());
  //     // cv::imshow("Stereo", viz);
  //     cv::imwrite("./images/" + std::to_string(frame_idx) + ".png", viz);
  //     // cv::waitKey(1);
  //     last_ts = cam_ts[0];
  //     frame_idx++;
  //   }
  // }

  // Run cameras
  std::vector<std::thread> threads;
  std::mutex mtx;

  auto thread_func = [&](const int cam_idx) {
    while (true) {
      cv::Mat image;
      timestamp_t ts;
      // ArduCam_softTrigger(cameras[0]->handle());
      if (cameras[cam_idx]->update(image, ts) == 0) {
        std::lock_guard<std::mutex> guard(mtx);
        cam_frames[cam_idx] = image;
        cam_ts[cam_idx] = ts;
      }
    }
  };

  for (int cam_idx = 0; cam_idx < num_cameras; cam_idx++) {
    std::thread th(thread_func, cam_idx);
    threads.push_back(std::move(th));
  }

  int frame_idx = 0;
  timestamp_t last_ts = 0;
  while (true) {
    std::lock_guard<std::mutex> guard(mtx);
    const auto cams_ok = cam_ts.size() == 2 && cam_ts[0] > 0;
    const auto timestamps_ok = fabs(ts2sec(cam_ts[0]) - ts2sec(cam_ts[1])) <= 0.008;
    const auto last_seen_ok = cam_ts[0] != last_ts;
    if (!(cams_ok && timestamps_ok && last_seen_ok)) {
      continue;
    }

    cv::Mat viz = cam_frames[0];
    for (size_t i = 1; i < cam_frames.size(); i++) {
      cv::hconcat(viz, cam_frames[i], viz);
    }

    printf("frame: %d\n", frame_idx);
    printf("cam0 ts: %ld\n", cam_ts[0]);
    printf("cam1 ts: %ld\n", cam_ts[1]);
    printf("last ts: %ld\n", last_ts);
    printf("diff ts: %f\n", fabs(ts2sec(cam_ts[0]) - ts2sec(cam_ts[1])));
    printf("\n");

    printf("fps: %f\n", cameras[0]->fps());
    cv::imshow("Stereo", viz);
    cv::imwrite("./images/" + std::to_string(frame_idx) + ".png", viz);
    cv::waitKey(1);
    last_ts = cam_ts[0];
    frame_idx++;
  }

  // Wait for join
  for (auto &th : threads) {
    th.join();
  }

  return 0;
}

#endif // ARDUCAM_IMPLEMENTATION
