<div class="header_path">prototype/dataset/euroc.hpp</div>

<!-- CLASSES -->
<div class="cpp_class">
  <pre><code class="cpp">struct euroc_imu_t {
  EIGEN_MAKE_ALIGNED_OPERATOR_NEW bool ok;
  std::string data_dir;
  timestamps_t timestamps;
  vec3s_t w_B;
  vec3s_t a_B;
  std::string sensor_type;
  std::string comment;
  mat4_t T_BS;
  double rate_hz;
  double gyro_noise_density;
  double gyro_random_walk;
  double accel_noise_density;
  double accel_random_walk;

  euroc_imu_t();
  euroc_imu_t(const std::string &amp;data_dir_);
  ~euroc_imu_t();
};</code></pre>
  
</div> <!-- .cpp_class -->
<!-- CLASSES -->
<div class="cpp_class">
  <pre><code class="cpp">struct euroc_camera_t {
  EIGEN_MAKE_ALIGNED_OPERATOR_NEW bool ok;
  std::string data_dir;
  timestamps_t timestamps;
  std::vector&lt;std::string&gt; image_paths;
  std::string sensor_type;
  std::string comment;
  mat4_t T_BS;
  double rate_hz;
  vec2_t resolution;
  std::string camera_model;
  vec4_t intrinsics;
  std::string distortion_model;
  vec4_t distortion_coefficients;

  euroc_camera_t();
  euroc_camera_t(const std::string &amp;data_dir_, bool is_calib_data_);
  ~euroc_camera_t();
};</code></pre>
  
</div> <!-- .cpp_class -->
<!-- CLASSES -->
<div class="cpp_class">
  <pre><code class="cpp">struct euroc_ground_truth_t {
  EIGEN_MAKE_ALIGNED_OPERATOR_NEW bool ok;
  std::string data_dir;
  timestamps_t timestamps;
  vec3s_t p_RS_R;
  vec4s_t q_RS;
  vec3s_t v_RS_R;
  vec3s_t b_w_RS_S;
  vec3s_t b_a_RS_S;

  euroc_ground_truth_t();
  euroc_ground_truth_t(const std::string &amp;data_dir_);
  ~euroc_ground_truth_t();
};</code></pre>
  
</div> <!-- .cpp_class -->
<!-- CLASSES -->
<div class="cpp_class">
  <pre><code class="cpp">struct euroc_data_t {
  EIGEN_MAKE_ALIGNED_OPERATOR_NEW bool ok;
  std::string data_path;
  euroc_imu_t imu_data;
  euroc_camera_t cam0_data;
  euroc_camera_t cam1_data;
  euroc_ground_truth_t ground_truth;
  cv::Size image_size;
  timestamp_t ts_start;
  timestamp_t ts_end;
  timestamp_t ts_now;
  long time_index;
  long imu_index;
  long frame_index;
  std::set&lt;timestamp_t&gt; timestamps;
  std::map&lt;timestamp_t, double&gt; time;
  std::multimap&lt;timestamp_t, timeline_event_t&lt;timestamp_t&gt; &gt; timeline;

  euroc_data_t();
  euroc_data_t(const std::string &amp;data_path);
  ~euroc_data_t();
};</code></pre>
  
</div> <!-- .cpp_class -->
<!-- CLASSES -->
<div class="cpp_class">
  <pre><code class="cpp">struct euroc_target_t {
  bool ok;
  std::string file_path;
  std::string type;
  int tag_rows;
  int tag_cols;
  double tag_size;
  double tag_spacing;

  euroc_target_t();
  euroc_target_t(const std::string &amp;file_path);
  ~euroc_target_t();
};</code></pre>
  
</div> <!-- .cpp_class -->
<!-- CLASSES -->
<div class="cpp_class">
  <pre><code class="cpp">struct euroc_calib_t {
  bool ok;
  std::string data_path;
  bool imshow;
  euroc_imu_t imu_data;
  euroc_camera_t cam0_data;
  euroc_camera_t cam1_data;
  euroc_target_t calib_target;
  cv::Size image_size;

  euroc_calib_t();
  euroc_calib_t(const std::string &amp;data_path);
  ~euroc_calib_t();
};</code></pre>
  
</div> <!-- .cpp_class -->

<!-- FUNCTIONS -->
<h2>Functions</h2>

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">int euroc_imu_load(euroc_imu_t &amp;data, const std::string &amp;data_dir);
</code></pre>
  
  <div class="doc"><p><p>Load IMU data</p>
<ul>
<li>[in] data IMU data</li>
<li>[in] data_dir Data directory</li>
</ul>
<p><strong>Returns</strong> 0 for success, -1 for failure</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">int euroc_camera_load(euroc_camera_t &amp;data,
                      const std::string &amp;data_dir,
                      const bool is_calib_data);
</code></pre>
  
  <div class="doc"><p><p>Load Camera data</p>
<ul>
<li>[in,out] data Camera data</li>
<li>[in] data_dir Data directory</li>
<li>[in] is_calib_data Is camera data for calibration?</li>
</ul>
<p><strong>Returns</strong> 0 for success, -1 for failure</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">int euroc_ground_truth_load(euroc_ground_truth_t &amp;data,
                            const std::string &amp;data_dir);
</code></pre>
  
  <div class="doc"><p><p>Load ground truth data</p>
<ul>
<li>[in,out] data Ground truth data</li>
<li>[in] data_dir Data directory</li>
</ul>
<p><strong>Returns</strong> 0 for success, -1 for failure</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">int euroc_data_load(euroc_data_t &amp;data, const std::string &amp;data_path);
</code></pre>
  
  <div class="doc"><p><p>Load dataset</p>
<ul>
<li>[in,out] data Dataset</li>
<li>[in] data_dir Data directory</li>
</ul>
<p><strong>Returns</strong> 0 for success, -1 for failure</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">void euroc_data_reset(euroc_data_t &amp;data);
</code></pre>
  
  <div class="doc"><p><p>Reset</p>
<ul>
<li>[in,out] data Dataset</li>
</ul>
<p><strong>Returns</strong> 0 for success, -1 for failure</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">timestamp_t euroc_data_min_timestamp(const euroc_data_t &amp;data);
</code></pre>
  
  <div class="doc"><p><p>Return min timestamp</p>
<ul>
<li>[in] data Dataset</li>
</ul>
<p><strong>Returns</strong> Minimum timestamp</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">timestamp_t euroc_data_max_timestamp(const euroc_data_t &amp;data);
</code></pre>
  
  <div class="doc"><p><p>Return max timestamp</p>
<p><strong>Returns</strong> Maximum timestamp</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">int euroc_target_load(euroc_target_t &amp;target, const std::string &amp;target_file);
</code></pre>
  
  <div class="doc"><p><p>Load calibration target settings</p>
<ul>
<li>target_file Path to target yaml file</li>
</ul>
<p><strong>Returns</strong> 0 for success, -1 for failure</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">int euroc_calib_load(euroc_calib_t &amp;data, const std::string &amp;data_path);
</code></pre>
  
  <div class="doc"><p><p>Load calibration data</p>
<p><strong>Returns</strong> 0 for success, -1 for failure</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">int process_stereo_images(const euroc_calib_t &amp;calib_data,
                          const std::string &amp;preprocess_path,
                          const mat3_t &amp;cam0_K,
                          const vec4_t &amp;cam0_D,
                          const mat3_t &amp;cam1_K,
                          const vec4_t &amp;cam1_D,
                          aprilgrids_t &amp;cam0_grids,
                          aprilgrids_t &amp;cam1_grids);
</code></pre>
  
  <div class="doc"><p><p>Process EuRoC calibration data and detect the AprilGrid detected from both
cameras. The detected AprilGrids will be outputted as files into the
<code>preprocess_path</code>, and as <code>aprilgrids_t</code> in <code>cam0_grids</code> and <code>cam1_grids</code>.</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">timeline_t&lt;timestamp_t&gt; create_timeline(const euroc_calib_t &amp;calib_data,
                                        const aprilgrids_t &amp;cam0_grids,
                                        const aprilgrids_t &amp;cam1_grids,
                                        const mat4_t &amp;T_SC0,
                                        mat4s_t &amp;T_WS,
                                        mat4_t &amp;T_WF,
                                        timestamp_t &amp;t0);
</code></pre>
  
  <div class="doc"><p><p>Create timeline from EuRoC calibration data <code>calib_data</code>. The timeline data
will put the detected aprilgrids from cam0 and cam1 inplace of the cam0 and
cam1 image paths. Using the aprilgrid data and initial sensor-camera
extrinsics <code>T_SC0</code>, the initial sensor poses in world frame <code>T_WS</code>, fiducial
pose in world frame <code>T_WF</code> and finally first timestamp <code>t0</code> will be
calculated.</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">std::ostream operator&lt;&lt;(std::ostream &amp;os, const euroc_imu_t &amp;data);
</code></pre>
  
  <div class="doc"><p><p><code>euroc_imu_t</code> to output stream</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">std::ostream operator&lt;&lt;(std::ostream &amp;os, const euroc_camera_t &amp;data);
</code></pre>
  
  <div class="doc"><p><p><code>euroc_camera_t</code> to output stream</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">std::ostream operator&lt;&lt;(std::ostream &amp;os, const euroc_target_t &amp;target);
</code></pre>
  
  <div class="doc"><p><p><code>calib_target_t</code> to output stream</p></p><hr></div>
  
</div> <!-- .cpp_func -->



</div> <!-- #content -->