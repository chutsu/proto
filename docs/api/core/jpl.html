<div class="header_path">prototype/core/jpl.hpp</div>


<!-- FUNCTIONS -->
<h2>Functions</h2>

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">template &lt;typename Derived, typename OtherDerived&gt;
void skew(const Eigen::MatrixBase&lt;Derived&gt; &amp;vector,
          Eigen::MatrixBase&lt;OtherDerived&gt; const &amp;matrix_const);
</code></pre>
  
  <div class="doc"><p><p>Skew</p>
<ul>
<li>vector Quaternion</li>
<li>matrix_const Skew matrix</li>
</ul></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">template &lt;typename Derived1, typename Derived2, typename Derived3&gt;
void signed_quatmul(const Eigen::MatrixBase&lt;Derived1&gt; &amp;q1,
                    const Eigen::MatrixBase&lt;Derived2&gt; &amp;q2,
                    const Eigen::MatrixBase&lt;Derived3&gt; &amp;product_const);
</code></pre>
  
  <div class="doc"><p><p>Signed quaternion product</p>
<ul>
<li>q1 First quaternion</li>
<li>q2 Second quaternion</li>
<li>product_const Quaternion product</li>
</ul></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">template &lt;typename Derived1, typename Derived2, typename Derived3&gt;
void positive_quatmul(const Eigen::MatrixBase&lt;Derived1&gt; &amp;q1,
                      const Eigen::MatrixBase&lt;Derived2&gt; &amp;q2,
                      const Eigen::MatrixBase&lt;Derived3&gt; &amp;product_const);
</code></pre>
  
  <div class="doc"><p><p>Positive quaternion product</p>
<ul>
<li>q1 First quaternion</li>
<li>q2 Second quaternion</li>
<li>product_const Quaternion product</li>
</ul></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">double quatnorm(const vec4_t &amp;q);
</code></pre>
  
  <div class="doc"><p><p>Quaternion norm</p>
<ul>
<li>q Quaternion in (x, y, z, w)</li>
</ul>
<p><strong>Returns</strong> Norm of quaternion</p></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">vec4_t quatnormalize(const vec4_t &amp;q);
</code></pre>
  
  <div class="doc"><p><p>Quaternion normalize</p>
<ul>
<li>q Quaternion in (x, y, z, w)</li>
</ul>
<p><strong>Returns</strong> Normalized quaternion</p></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">vec4_t quatconj(const vec4_t &amp;q);
</code></pre>
  
  <div class="doc"><p><p>Quaternion conjugate</p>
<p>Page 4. of Trawny, Nikolas, and Stergios I. Roumeliotis. "Indirect
Kalman filter for 3D attitude estimation." University of Minnesota,
Dept. of Comp. Sci. &amp; Eng., Tech. Rep 2 (2005): 2005.</p>
<ul>
<li>q Quaternion in (x, y, z, w)</li>
</ul>
<p><strong>Returns</strong> Conjugate of quaternion</p></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">vec4_t quatmul(const vec4_t &amp;p, const vec4_t &amp;q);
</code></pre>
  
  <div class="doc"><p><p>Quaternion multiply</p>
<p>Page 3. of Trawny, Nikolas, and Stergios I. Roumeliotis. "Indirect
Kalman filter for 3D attitude estimation." University of Minnesota,
Dept. of Comp. Sci. &amp; Eng., Tech. Rep 2 (2005): 2005.</p>
<ul>
<li>p Quaternion in (x, y, z, w)</li>
<li>q Quaternion in (x, y, z, w)</li>
</ul>
<p><strong>Returns</strong> Product of quaternions p and q</p></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat3_t quat2rot(const vec4_t &amp;q);
</code></pre>
  
  <div class="doc"><p><p>Quaternion to Rotation Matrix</p>
<p>Page 9. of Trawny, Nikolas, and Stergios I. Roumeliotis. "Indirect
Kalman filter for 3D attitude estimation." University of Minnesota,
Dept. of Comp. Sci. &amp; Eng., Tech. Rep 2 (2005): 2005.</p>
<ul>
<li>q Quaternion in (x, y, z, w)</li>
</ul>
<p><strong>Returns</strong> Rotation matrix</p></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat4_t quatlcomp(const vec4_t &amp;q);
</code></pre>
  
  <div class="doc"><p><p>Quaternion left-compound</p>
<p>Page 4. of Trawny, Nikolas, and Stergios I. Roumeliotis. "Indirect
Kalman filter for 3D attitude estimation." University of Minnesota,
Dept. of Comp. Sci. &amp; Eng., Tech. Rep 2 (2005): 2005.</p>
<ul>
<li>q Quaternion in (x, y, z, w)</li>
</ul>
<p><strong>Returns</strong> Quaternion left-compound</p></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat4_t quatrcomp(const vec4_t &amp;q);
</code></pre>
  
  <div class="doc"><p><p>Quaternion right-compound</p>
<p>Page 4. of Trawny, Nikolas, and Stergios I. Roumeliotis. "Indirect
Kalman filter for 3D attitude estimation." University of Minnesota,
Dept. of Comp. Sci. &amp; Eng., Tech. Rep 2 (2005): 2005.</p>
<ul>
<li>q Quaternion in (x, y, z, w)</li>
</ul>
<p><strong>Returns</strong> Quaternion right-compound</p></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">vec4_t quatsmallangle(const vec3_t &amp;dtheta);
</code></pre>
  
  <div class="doc"><p><p>Convert the vector part of a quaternion to a full quaternion.</p>
<p>This function is useful to convert delta quaternion which is usually a 3x1
vector to a full quaternion.  For more details, check Section 3.2 Kalman
Filter Update of Equation (217) and (218) in "Indirect Kalman Filter for 3D
Attitude Estimation" by Trawny and Roumeliotis.</p>
<ul>
<li>dtheta Small angle vector to form full quaternion with</li>
</ul>
<p><strong>Returns</strong> Small angle Quaternion</p></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">vec3_t quat2euler(const vec4_t &amp;q);
</code></pre>
  
  <div class="doc"><p><p>Quaternion to Euler-angles</p>
<ul>
<li>q Quaternion in (x, y, z, w)</li>
</ul>
<p><strong>Returns</strong> Euler-angles</p></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">vec4_t euler2quat(const vec3_t &amp;rpy);
</code></pre>
  
  <div class="doc"><p><p>Euler-angles to Quaternion</p>
<ul>
<li>rpy Euler-angles in (roll, pitch, yaw)</li>
</ul>
<p><strong>Returns</strong> Quaternion</p></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">vec4_t rot2quat(const mat3_t &amp;rot);
</code></pre>
  
  <div class="doc"><p><p>Rotation matrix to Quaternion</p></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat3_t C(const vec4_t &amp;q);
</code></pre>
  
  <div class="doc"><p><p>Quaternion to Rotation Matrix</p>
<ul>
<li>q Quaternion in (x, y, z, w)</li>
</ul>
<p><strong>Returns</strong> Rotation matrix</p></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat4_t Omega(const vec3_t &amp;w);
</code></pre>
  
  <div class="doc"><p><p>Omega function</p>
<ul>
<li>w Angular velocity</li>
</ul>
<p><strong>Returns</strong> Differential form of an angular velocity</p></p></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">vec4_t quatzoi(const vec4_t &amp;q, const vec3_t &amp;w, const double dt);
</code></pre>
  
  <div class="doc"><p><p>Quaternion Zeroth order integration</p>
<p>Page 12-13 of Trawny, Nikolas, and Stergios I. Roumeliotis. "Indirect Kalman
filter for 3D attitude estimation." University of Minnesota, Dept. of Comp.
Sci. &amp; Eng., Tech. Rep 2 (2005): 2005.</p>
<ul>
<li>q Quaternion in (x, y, z, w)</li>
<li>w Angular velocity</li>
<li>dt Time difference (s)</li>
</ul>
<p><strong>Returns</strong> Zeroth order integrated quaternion</p></p></div>
  
</div> <!-- .cpp_func -->



</div> <!-- #content -->