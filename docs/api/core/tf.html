<div class="header_path">proto/core/tf.hpp</div>


<!-- FUNCTIONS -->
<h2>Functions</h2>

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat3_t tf_rot(const mat4_t &amp;tf);
</code></pre>
  
  <div class="doc"><p><p>Extract rotation from transform</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">quat_t tf_quat(const mat4_t &amp;tf);
</code></pre>
  
  <div class="doc"><p><p>Extract rotation and convert to quaternion from transform</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">vec3_t tf_trans(const mat4_t &amp;tf);
</code></pre>
  
  <div class="doc"><p><p>Extract translation from transform</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat4_t tf(const mat3_t &amp;C, const vec3_t &amp;r);
</code></pre>
  
  <div class="doc"><p><p>Form a 4x4 homogeneous transformation matrix from a
rotation matrix <code>C</code> and translation vector <code>r</code>.</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat4_t tf(const quat_t &amp;q, const vec3_t &amp;r);
</code></pre>
  
  <div class="doc"><p><p>Form a 4x4 homogeneous transformation matrix from a
Hamiltonian quaternion <code>q</code> and translation vector <code>r</code>.</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat3_t rotx(const double theta);
</code></pre>
  
  <div class="doc"><p><p>Rotation matrix around x-axis (counter-clockwise, right-handed).</p>
<p><strong>Returns</strong> Rotation matrix</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat3_t roty(const double theta);
</code></pre>
  
  <div class="doc"><p><p>Rotation matrix around y-axis (counter-clockwise, right-handed).</p>
<p><strong>Returns</strong> Rotation matrix</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat3_t rotz(const double theta);
</code></pre>
  
  <div class="doc"><p><p>Rotation matrix around z-axis (counter-clockwise, right-handed).</p>
<p><strong>Returns</strong> Rotation matrix</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat3_t euler123(const vec3_t &amp;euler);
</code></pre>
  
  <div class="doc"><p><p>Convert euler sequence 123 to rotation matrix R
This function assumes we are performing a body fixed intrinsic rotation.</p>
<p>Source:</p>
<pre><code>Kuipers, Jack B. Quaternions and Rotation Sequences: A Primer with
Applications to Orbits, Aerospace, and Virtual Reality. Princeton, N.J:
Princeton University Press, 1999. Print.

Page 86.
</code></pre>
<p><strong>Returns</strong> Rotation matrix</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat3_t euler321(const vec3_t &amp;euler);
</code></pre>
  
  <div class="doc"><p><p>Convert euler sequence 321 to rotation matrix R
This function assumes we are performing a body fixed intrinsic rotation.</p>
<p>Source:</p>
<pre><code>Kuipers, Jack B. Quaternions and Rotation Sequences: A Primer with
Applications to Orbits, Aerospace, and Virtual Reality. Princeton, N.J:
Princeton University Press, 1999. Print.

Page 86.
</code></pre>
<p><strong>Returns</strong> Rotation matrix</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">quat_t euler2quat(const vec3_t &amp;euler);
</code></pre>
  
  <div class="doc"><p><p>Convert roll, pitch and yaw to quaternion.</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat3_t vecs2rot(const vec3_t &amp;a_m, const vec3_t &amp;g);
</code></pre>
  
  <div class="doc"><p><p>Convert rotation vectors to rotation matrix using measured acceleration
<code>a_m</code> from an IMU and gravity vector <code>g</code>.</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">vec3_t quat2euler(const quat_t &amp;q);
</code></pre>
  
  <div class="doc"><p><p>Convert quaternion to euler angles.</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">void imu_init_attitude(const vec3s_t w_m,
                       const vec3s_t a_m,
                       mat3_t &amp;C_WS,
                       const size_t buffer_size);
</code></pre>
  
  <div class="doc"><p><p>Initialize attitude using IMU gyroscope <code>w_m</code> and accelerometer <code>a_m</code>
measurements. The calculated attitude outputted into to <code>C_WS</code>. Note: this
function does not calculate initial yaw angle in the world frame. Only the
roll, and pitch are inferred from IMU measurements.</p></p><hr></div>
  
</div> <!-- .cpp_func -->



</div> <!-- #content -->