<div class="header_path">proto/vision/vision_common.hpp</div>


<!-- FUNCTIONS -->
<h2>Functions</h2>

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">bool is_equal(const cv::Mat &amp;m1, const cv::Mat &amp;m2);
</code></pre>
  
  <div class="doc"><p><p>Compare <code>cv::Mat</code> whether they are equal</p>
<ul>
<li>m1 First matrix</li>
<li>m2 Second matrix</li>
</ul>
<p><strong>Returns</strong> true or false</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">void convert(const cv::Mat &amp;x, matx_t &amp;y);
</code></pre>
  
  <div class="doc"><p><p>Convert cv::Mat to Eigen::Matrix</p>
<ul>
<li>x Input matrix</li>
<li>y Output matrix</li>
</ul></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">void convert(const matx_t &amp;x, cv::Mat &amp;y);
</code></pre>
  
  <div class="doc"><p><p>Convert Eigen::Matrix to cv::Mat</p>
<ul>
<li>x Input matrix</li>
<li>y Output matrix</li>
</ul></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">matx_t convert(const cv::Mat &amp;x);
</code></pre>
  
  <div class="doc"><p><p>Convert cv::Mat to Eigen::Matrix</p>
<ul>
<li>x Input matrix</li>
</ul>
<p><strong>Returns</strong> Matrix as Eigen::Matrix</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">cv::Mat convert(const matx_t &amp;x);
</code></pre>
  
  <div class="doc"><p><p>Convert Eigen::Matrix to cv::Mat</p>
<ul>
<li>x Input matrix</li>
</ul>
<p><strong>Returns</strong> Matrix as cv::Mat</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">vec3_t homogeneous(const vec2_t &amp;x);
</code></pre>
  
  <div class="doc"><p><p>Convert x to homogenous coordinates</p>
<ul>
<li>x Input vector</li>
</ul>
<p><strong>Returns</strong> Output vector in homogeneous coordinates</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">vec4_t homogeneous(const vec3_t &amp;x);
</code></pre>
  
  <div class="doc"><p><p>Convert x to homogenous coordinates</p>
<ul>
<li>x Input vector</li>
</ul>
<p><strong>Returns</strong> Output vector in homogeneous coordinates</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">vec2_t normalize(const vec2_t &amp;x);
</code></pre>
  
  <div class="doc"><p><p>Normalize vector of</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">mat4_t rvectvec2transform(const cv::Mat &amp;rvec, const cv::Mat &amp;tvec);
</code></pre>
  
  <div class="doc"><p><p>Convert rvec, tvec into transform matrix</p>
<ul>
<li>rvec Rodrigues rotation vector</li>
<li>tvec Translation vector</li>
</ul>
<p><strong>Returns</strong> Transform matrix</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">cv::Matx33d skew(const cv::Vec3d &amp;v);
</code></pre>
  
  <div class="doc"><p><p>Skew symmetric matrix</p>
<ul>
<li>v Vector</li>
</ul>
<p><strong>Returns</strong> Skew symmetric matrix</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">std::vector&lt;cv::KeyPoint&gt;
sort_keypoints(const std::vector&lt;cv::KeyPoint&gt; keypoints, const size_t limit);
</code></pre>
  
  <div class="doc"><p><p>Sort Keypoints</p>
<ul>
<li>keypoints</li>
<li>limit</li>
</ul>
<p><strong>Returns</strong> Sorted keypoints by response</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">cv::Mat gray2rgb(const cv::Mat &amp;image);
</code></pre>
  
  <div class="doc"><p><p>Convert gray-scale image to rgb image</p>
<ul>
<li>image</li>
</ul>
<p><strong>Returns</strong> RGB image</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">cv::Mat rgb2gray(const cv::Mat &amp;image);
</code></pre>
  
  <div class="doc"><p><p>Convert rgb image to gray-scale image</p>
<ul>
<li>image</li>
</ul>
<p><strong>Returns</strong> Gray-scale image</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">cv::Mat roi(const cv::Mat &amp;image,
            const int width,
            const int height,
            const double cx,
            const double cy);
</code></pre>
  
  <div class="doc"><p><p>Create ROI from an image</p>
<ul>
<li>[in] image Input image</li>
<li>[in] width ROI width</li>
<li>[in] height ROI height</li>
<li>[in] cx ROI center x-axis</li>
<li>[in] cy ROI center y-axis</li>
</ul>
<p><strong>Returns</strong> ROI</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">bool keypoint_compare_by_response(const cv::KeyPoint &amp;kp1,
                                  const cv::KeyPoint &amp;kp2);
</code></pre>
  
  <div class="doc"><p><p>Compare two keypoints based on the response.</p>
<ul>
<li>[in] kp1 First keypoint</li>
<li>[in] kp2 Second keypoint</li>
</ul>
<p><strong>Returns</strong> Boolean to denote if first keypoint repose is larger than second</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">bool is_rot_mat(const cv::Mat &amp;R);
</code></pre>
  
  <div class="doc"><p><p>Check to see if rotation matrix is valid (not singular)</p>
<ul>
<li>[in] R Rotation matrix</li>
</ul>
<p><strong>Returns</strong> Boolean to denote whether rotation matrix is valid</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">cv::Vec3f rot2euler(const cv::Mat &amp;R);
</code></pre>
  
  <div class="doc"><p><p>Convert rotation matrix to euler angles</p>
<ul>
<li>[in] R Rotation matrix</li>
</ul>
<p><strong>Returns</strong> Euler angles</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">float rescale_points(vec2s_t &amp;pts1, std::vector&lt;vec2_t&gt; &amp;pts2);
</code></pre>
  
  <div class="doc"><p><p>Rescale points</p>
<ul>
<li>[in] pts1 Points 1</li>
<li>[in] pts2 Points 2</li>
</ul>
<p><strong>Returns</strong> scaling_factor Scaling factor</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">double reprojection_error(const vec2s_t &amp;measured, const vec2s_t &amp;projected);
</code></pre>
  
  <div class="doc"><p><p>Calculate reprojection error</p>
<ul>
<li>[in] measured Measured image pixels</li>
<li>[in] projected Projected image pixels</li>
</ul>
<p><strong>Returns</strong> Reprojection error</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">double reprojection_error(const std::vector&lt;cv::Point2f&gt; &amp;measured,
                          const std::vector&lt;cv::Point2f&gt; &amp;projected);
</code></pre>
  
  <div class="doc"><p><p>Calculate reprojection error</p>
<ul>
<li>[in] measured Measured image pixels</li>
<li>[in] projected Projected image pixels</li>
</ul>
<p><strong>Returns</strong> Reprojection error</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">matx_t feature_mask(const int image_width,
                    const int image_height,
                    const std::vector&lt;cv::Point2f&gt; points,
                    const int patch_width);
</code></pre>
  
  <div class="doc"><p><p>Create feature mask</p>
<ul>
<li>[in] image_width Image width</li>
<li>[in] image_height Image height</li>
<li>[in] points Points</li>
<li>[in] patch_width Patch width</li>
</ul>
<p><strong>Returns</strong> Feature mask</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">matx_t feature_mask(const int image_width,
                    const int image_height,
                    const std::vector&lt;cv::KeyPoint&gt; keypoints,
                    const int patch_width);
</code></pre>
  
  <div class="doc"><p><p>Create feature mask</p>
<ul>
<li>[in] image_width Image width</li>
<li>[in] image_height Image height</li>
<li>[in] keypoints Keypoints</li>
<li>[in] patch_width Patch width</li>
</ul>
<p><strong>Returns</strong> Feature mask</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">cv::Mat feature_mask_opencv(const int image_width,
                            const int image_height,
                            const std::vector&lt;cv::Point2f&gt; points,
                            const int patch_width);
</code></pre>
  
  <div class="doc"><p><p>Create feature mask</p>
<ul>
<li>[in] image_width Image width</li>
<li>[in] image_height Image height</li>
<li>[in] points Points</li>
<li>[in] patch_width Patch width</li>
</ul>
<p><strong>Returns</strong> Feature mask</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">cv::Mat feature_mask_opencv(const int image_width,
                            const int image_height,
                            const std::vector&lt;cv::KeyPoint&gt; keypoints,
                            const int patch_width);
</code></pre>
  
  <div class="doc"><p><p>Create feature mask</p>
<ul>
<li>[in] image_width Image width</li>
<li>[in] image_height Image height</li>
<li>[in] keypoints Keypoints</li>
<li>[in] patch_width Patch width</li>
</ul>
<p><strong>Returns</strong> Feature mask</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">cv::Mat radtan_undistort_image(const mat3_t &amp;K,
                               const vecx_t &amp;D,
                               const cv::Mat &amp;image);
</code></pre>
  
  <div class="doc"><p><p>Equi undistort image</p>
<ul>
<li>[in] K Camera matrix K</li>
<li>[in] D Distortion vector D</li>
<li>[in] image Input image</li>
</ul>
<p><strong>Returns</strong> Undistorted image using radial-tangential distortion</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">cv::Mat equi_undistort_image(const mat3_t &amp;K,
                             const vecx_t &amp;D,
                             const cv::Mat &amp;image,
                             const double balance,
                             cv::Mat &amp;Knew);
</code></pre>
  
  <div class="doc"><p><p>Equi undistort image</p>
<ul>
<li>[in] K Camera matrix K</li>
<li>[in] D Distortion vector D</li>
<li>[in] image Input image</li>
<li>[in] balance Balance</li>
<li>[in,out] Knew New camera matrix K</li>
</ul>
<p><strong>Returns</strong> Undistorted image using equidistant distortion</p></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">void illum_invar_transform(cv::Mat &amp;image,
                           const double lambda_1,
                           const double lambda_2,
                           const double lambda_3);
</code></pre>
  
  <div class="doc"><p><p>Illumination invariant transform.</p>
<ul>
<li>[in] image Image</li>
<li>[in] lambda_1 Lambad 1</li>
<li>[in] lambda_2 Lambad 2</li>
<li>[in] lambda_3 Lambad 3</li>
</ul></p><hr></div>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">double lapm(const cv::Mat &amp;src);
</code></pre>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">double lapv(const cv::Mat &amp;src);
</code></pre>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">double teng(const cv::Mat &amp;src, int ksize);
</code></pre>
  
</div> <!-- .cpp_func -->

<div class="cpp_func" onclick=show_doc(this)>
  <pre><code class="cpp">double glvn(const cv::Mat &amp;src);
</code></pre>
  
</div> <!-- .cpp_func -->



</div> <!-- #content -->