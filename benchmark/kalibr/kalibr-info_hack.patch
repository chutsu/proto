diff --git a/aslam_incremental_calibration/incremental_calibration/include/aslam/calibration/core/IncrementalEstimator.h b/aslam_incremental_calibration/incremental_calibration/include/aslam/calibration/core/IncrementalEstimator.h
index 60982d9..9d7d886 100644
--- a/aslam_incremental_calibration/incremental_calibration/include/aslam/calibration/core/IncrementalEstimator.h
+++ b/aslam_incremental_calibration/incremental_calibration/include/aslam/calibration/core/IncrementalEstimator.h
@@ -200,6 +200,8 @@ namespace aslam {
       OptimizerOptions& getOptimizerOptions();
       /// Return the marginalized group ID
       size_t getMargGroupId() const;
+      // Returns svLog2Sum
+      double getSvLog2Sum() const;
       /// Returns the last information gain
       double getInformationGain() const;
       /// Returns the current Jacobian transpose if available
@@ -240,7 +242,6 @@ namespace aslam {
       /** @}
         */
 
-    protected:
       /** \name Protected methods
         @{
         */
diff --git a/aslam_incremental_calibration/incremental_calibration/src/core/IncrementalEstimator.cpp b/aslam_incremental_calibration/incremental_calibration/src/core/IncrementalEstimator.cpp
index 25a4122..14875be 100644
--- a/aslam_incremental_calibration/incremental_calibration/src/core/IncrementalEstimator.cpp
+++ b/aslam_incremental_calibration/incremental_calibration/src/core/IncrementalEstimator.cpp
@@ -152,6 +152,10 @@ namespace aslam {
       return _margGroupId;
     }
 
+    double IncrementalEstimator::getSvLog2Sum() const {
+      return _svLog2Sum;
+    }
+
     double IncrementalEstimator::getInformationGain() const {
       return _informationGain;
     }
diff --git a/aslam_incremental_calibration/incremental_calibration_python/src/IncrementalEstimator.cpp b/aslam_incremental_calibration/incremental_calibration_python/src/IncrementalEstimator.cpp
index 2367622..dc2cb25 100644
--- a/aslam_incremental_calibration/incremental_calibration_python/src/IncrementalEstimator.cpp
+++ b/aslam_incremental_calibration/incremental_calibration_python/src/IncrementalEstimator.cpp
@@ -175,6 +175,7 @@ void exportIncrementalEstimator() {
     .def("removeBatch", removeBatch1)
     .def("removeBatch", removeBatch2)
     .def("getMargGroupId", &IncrementalEstimator::getMargGroupId)
+    .def("getSvLog2Sum", &IncrementalEstimator::getSvLog2Sum)
     .def("getInformationGain", &IncrementalEstimator::getInformationGain)
     .def("getJacobianTranspose", &IncrementalEstimator::getJacobianTranspose,
       return_internal_reference<>())
diff --git a/aslam_offline_calibration/kalibr/python/kalibr_calibrate_cameras b/aslam_offline_calibration/kalibr/python/kalibr_calibrate_cameras
index 33769b4..77233e8 100755
--- a/aslam_offline_calibration/kalibr/python/kalibr_calibrate_cameras
+++ b/aslam_offline_calibration/kalibr/python/kalibr_calibrate_cameras
@@ -22,6 +22,7 @@ import signal
 
 np.set_printoptions(suppress=True)
 
+
 def initBagDataset(bagfile, topic, from_to):
     print("\tDataset:          {0}".format(bagfile))
     print("\tTopic:            {0}".format(topic))
@@ -29,25 +30,31 @@ def initBagDataset(bagfile, topic, from_to):
     print("\tNumber of images: {0}".format(reader.numImages()))
     return reader
 
+
 #available models
-cameraModels = { 'pinhole-radtan': acvb.DistortedPinhole,
-                 'pinhole-equi':   acvb.EquidistantPinhole,
-                 'pinhole-fov':    acvb.FovPinhole,
-                 'omni-none':      acvb.Omni,
-                 'omni-radtan':    acvb.DistortedOmni,
-                 'eucm-none':      acvb.ExtendedUnified,
-                 'ds-none':        acvb.DoubleSphere}
+cameraModels = {
+    'pinhole-radtan': acvb.DistortedPinhole,
+    'pinhole-equi': acvb.EquidistantPinhole,
+    'pinhole-fov': acvb.FovPinhole,
+    'omni-none': acvb.Omni,
+    'omni-radtan': acvb.DistortedOmni,
+    'eucm-none': acvb.ExtendedUnified,
+    'ds-none': acvb.DoubleSphere
+}
+
 
 def signal_exit(signal, frame):
     sm.logWarn("Shutdown requested! (CTRL+C)")
     sys.exit(2)
 
+
 def parseArgs():
     class KalibrArgParser(argparse.ArgumentParser):
         def error(self, message):
             self.print_help()
             sm.logError('%s' % message)
             sys.exit(2)
+
         def format_help(self):
             formatter = self._get_formatter()
             formatter.add_text(self.description)
@@ -59,8 +66,8 @@ def parseArgs():
                 formatter.add_arguments(action_group._group_actions)
                 formatter.end_section()
             formatter.add_text(self.epilog)
-            return formatter.format_help()     
-        
+            return formatter.format_help()
+
     usage = """
     Example usage to calibrate a camera system with two cameras using an aprilgrid. 
     
@@ -76,70 +83,158 @@ def parseArgs():
         tagRows: 6
         tagSize: 0.088  #m
         tagSpacing: 0.3 #percent of tagSize"""
-            
-    parser = KalibrArgParser(description='Calibrate the intrinsics and extrinsics of a camera system with non-shared overlapping field of view.', usage=usage)
-    parser.add_argument('--models', nargs='+', dest='models', help='The camera model {0} to estimate'.format(list(cameraModels.keys())), required=True)
-    
+
+    parser = KalibrArgParser(
+        description=
+        'Calibrate the intrinsics and extrinsics of a camera system with non-shared overlapping field of view.',
+        usage=usage)
+    parser.add_argument('--models',
+                        nargs='+',
+                        dest='models',
+                        help='The camera model {0} to estimate'.format(
+                            list(cameraModels.keys())),
+                        required=True)
+
     groupSource = parser.add_argument_group('Data source')
-    groupSource.add_argument('--bag', dest='bagfile', help='The bag file with the data')
-    groupSource.add_argument('--topics', nargs='+', dest='topics', help='The list of image topics', required=True)
-    groupSource.add_argument('--bag-from-to', metavar='bag_from_to', type=float, nargs=2, help='Use the bag data starting from up to this time [s]')
-    
+    groupSource.add_argument('--bag',
+                             dest='bagfile',
+                             help='The bag file with the data')
+    groupSource.add_argument('--topics',
+                             nargs='+',
+                             dest='topics',
+                             help='The list of image topics',
+                             required=True)
+    groupSource.add_argument(
+        '--bag-from-to',
+        metavar='bag_from_to',
+        type=float,
+        nargs=2,
+        help='Use the bag data starting from up to this time [s]')
+
     groupTarget = parser.add_argument_group('Calibration target configuration')
-    groupTarget.add_argument('--target', dest='targetYaml', help='Calibration target configuration as yaml file', required=True)
-    
+    groupTarget.add_argument(
+        '--target',
+        dest='targetYaml',
+        help='Calibration target configuration as yaml file',
+        required=True)
+
     groupTarget = parser.add_argument_group('Image synchronization')
-    groupTarget.add_argument('--approx-sync', dest='max_delta_approxsync', type=float, default=0.02, help='Time tolerance for approximate image synchronization [s] (default: %(default)s)')
-    
+    groupTarget.add_argument(
+        '--approx-sync',
+        dest='max_delta_approxsync',
+        type=float,
+        default=0.02,
+        help=
+        'Time tolerance for approximate image synchronization [s] (default: %(default)s)'
+    )
+
     groupCalibrator = parser.add_argument_group('Calibrator settings')
-    groupCalibrator.add_argument('--qr-tol', type=float, default=0.02, dest='qrTol', help='The tolerance on the factors of the QR decomposition (default: %(default)s)')
-    groupCalibrator.add_argument('--mi-tol', type=float, default=0.2, dest='miTol', help='The tolerance on the mutual information for adding an image. Higher means fewer images will be added. Use -1 to force all images. (default: %(default)s)')
-    groupCalibrator.add_argument('--no-shuffle', action='store_true', dest='noShuffle', help='Do not shuffle the dataset processing order')
-    
+    groupCalibrator.add_argument(
+        '--qr-tol',
+        type=float,
+        default=0.02,
+        dest='qrTol',
+        help=
+        'The tolerance on the factors of the QR decomposition (default: %(default)s)'
+    )
+    groupCalibrator.add_argument(
+        '--mi-tol',
+        type=float,
+        default=0.2,
+        dest='miTol',
+        help=
+        'The tolerance on the mutual information for adding an image. Higher means fewer images will be added. Use -1 to force all images. (default: %(default)s)'
+    )
+    groupCalibrator.add_argument(
+        '--no-shuffle',
+        action='store_true',
+        dest='noShuffle',
+        help='Do not shuffle the dataset processing order')
+
     outlierSettings = parser.add_argument_group('Outlier filtering options')
-    outlierSettings.add_argument('--no-outliers-removal', action='store_false', default=True, dest='removeOutliers', help='Disable corner outlier filtering')
-    outlierSettings.add_argument('--no-final-filtering', action='store_false', default=True, dest='allowEndFiltering', help='Disable filtering after all views have been processed.')
-    outlierSettings.add_argument('--min-views-outlier', type=int, default=20, dest='minViewOutlier', help='Number of raw views to initialize statistics (default: %(default)s)')
-    outlierSettings.add_argument('--use-blakezisserman', action='store_true', dest='doBlakeZisserman', help='Enable the Blake-Zisserman m-estimator')
-    outlierSettings.add_argument('--plot-outliers', action='store_true', dest='doPlotOutliers', help='Plot the detect outliers during extraction (this could be slow)')
-    
+    outlierSettings.add_argument('--no-outliers-removal',
+                                 action='store_false',
+                                 default=True,
+                                 dest='removeOutliers',
+                                 help='Disable corner outlier filtering')
+    outlierSettings.add_argument(
+        '--no-final-filtering',
+        action='store_false',
+        default=True,
+        dest='allowEndFiltering',
+        help='Disable filtering after all views have been processed.')
+    outlierSettings.add_argument(
+        '--min-views-outlier',
+        type=int,
+        default=20,
+        dest='minViewOutlier',
+        help=
+        'Number of raw views to initialize statistics (default: %(default)s)')
+    outlierSettings.add_argument('--use-blakezisserman',
+                                 action='store_true',
+                                 dest='doBlakeZisserman',
+                                 help='Enable the Blake-Zisserman m-estimator')
+    outlierSettings.add_argument(
+        '--plot-outliers',
+        action='store_true',
+        dest='doPlotOutliers',
+        help='Plot the detect outliers during extraction (this could be slow)')
+
     outputSettings = parser.add_argument_group('Output options')
-    outputSettings.add_argument('--verbose', action='store_true', dest='verbose', help='Enable (really) verbose output (disables plots)')
-    outputSettings.add_argument('--show-extraction', action='store_true', dest='showextraction', help='Show the calibration target extraction. (disables plots)')
-    outputSettings.add_argument('--plot', action='store_true', dest='plot', help='Plot during calibration (this could be slow).')
-    outputSettings.add_argument('--dont-show-report', action='store_true', dest='dontShowReport', help='Do not show the report on screen after calibration.')
-       
+    outputSettings.add_argument(
+        '--verbose',
+        action='store_true',
+        dest='verbose',
+        help='Enable (really) verbose output (disables plots)')
+    outputSettings.add_argument(
+        '--show-extraction',
+        action='store_true',
+        dest='showextraction',
+        help='Show the calibration target extraction. (disables plots)')
+    outputSettings.add_argument(
+        '--plot',
+        action='store_true',
+        dest='plot',
+        help='Plot during calibration (this could be slow).')
+    outputSettings.add_argument(
+        '--dont-show-report',
+        action='store_true',
+        dest='dontShowReport',
+        help='Do not show the report on screen after calibration.')
+
     #print help if no argument is specified
-    if len(sys.argv)==1:
+    if len(sys.argv) == 1:
         parser.print_help()
         sys.exit(2)
-        
+
     #Parser the argument list
     try:
         parsed = parser.parse_args()
     except:
         sys.exit(2)
-    
+
     #some checks
     if len(parsed.topics) != len(parsed.models):
-        sm.logError("Please specify exactly one camera model (--models) for each topic (--topics).")
+        sm.logError(
+            "Please specify exactly one camera model (--models) for each topic (--topics)."
+        )
         sys.exit(2)
-        
-    if parsed.minViewOutlier<1:
+
+    if parsed.minViewOutlier < 1:
         sm.logError("Please specify a positive integer (--min-views-outlier).")
         sys.exit(2)
-    
+
     #there is a with the gtk plot widget, so we cant plot if we have opencv windows open...
     #--> disable the plots in these special situations
     if parsed.showextraction or parsed.verbose:
         parsed.dontShowReport = True
-    
+
     return parsed
 
 
 def main():
     parsed = parseArgs()
-    
+
     #logging modes
     if parsed.verbose:
         sm.setLoggingLevel(sm.LoggingLevel.Debug)
@@ -156,7 +251,7 @@ def main():
     numCams = len(parsed.topics)
 
     obsdb = kcc.ObservationDatabase(parsed.max_delta_approxsync)
-        
+
     for cam_id in range(0, numCams):
         topic = parsed.topics[cam_id]
         modelName = parsed.models[cam_id]
@@ -164,74 +259,101 @@ def main():
         print("\tCamera model:\t  {0}".format(modelName))
 
         if modelName in cameraModels:
-            #open dataset 
+            #open dataset
             dataset = initBagDataset(parsed.bagfile, topic, parsed.bag_from_to)
-        
+
             #create camera
             cameraModel = cameraModels[modelName]
-            cam = kcc.CameraGeometry(cameraModel, targetConfig, dataset, verbose=(parsed.verbose or parsed.showextraction))
-                
+            cam = kcc.CameraGeometry(cameraModel,
+                                     targetConfig,
+                                     dataset,
+                                     verbose=(parsed.verbose
+                                              or parsed.showextraction))
+
             #extract the targets
             multithreading = not (parsed.verbose or parsed.showextraction)
-            observations = kc.extractCornersFromDataset(cam.dataset, cam.ctarget.detector, 
-                                                        multithreading=multithreading, clearImages=False,
-                                                        noTransformation=True)
-            
+            observations = kc.extractCornersFromDataset(
+                cam.dataset,
+                cam.ctarget.detector,
+                multithreading=multithreading,
+                clearImages=False,
+                noTransformation=True)
+
             #populate the database
             for obs in observations:
                 obsdb.addObservation(cam_id, obs)
 
             #initialize the intrinsics
             if not cam.initGeometryFromObservations(observations):
-                raise RuntimeError("Could not initialize the intrinsics for camera with topic: {0}. Try to use --verbose and check whether the calibration target extraction is successful.".format(topic))
-            
-            print("\tProjection initialized to: %s" % cam.geometry.projection().getParameters().flatten())
-            print("\tDistortion initialized to: %s" % cam.geometry.projection().distortion().getParameters().flatten())
-            
+                raise RuntimeError(
+                    "Could not initialize the intrinsics for camera with topic: {0}. Try to use --verbose and check whether the calibration target extraction is successful."
+                    .format(topic))
+
+            print("\tProjection initialized to: %s" %
+                  cam.geometry.projection().getParameters().flatten())
+            print("\tDistortion initialized to: %s" % cam.geometry.projection(
+            ).distortion().getParameters().flatten())
+
             cameraList.append(cam)
         else:
-            raise RuntimeError( "Unknown camera model: {0}. Try {1}.".format(modelName, list(cameraModels.keys())) )
+            raise RuntimeError("Unknown camera model: {0}. Try {1}.".format(
+                modelName, list(cameraModels.keys())))
 
     if parsed.verbose:
         obsdb.printTable()
-    
+
     #initialize the calibration graph
     graph = kcc.MulticamCalibrationGraph(obsdb)
-    
+
     if not graph.isGraphConnected():
         obsdb.printTable()
-        print("Cameras are not connected through mutual observations, please check the dataset. Maybe adjust the approx. sync. tolerance.")
+        print(
+            "Cameras are not connected through mutual observations, please check the dataset. Maybe adjust the approx. sync. tolerance."
+        )
         graph.plotGraph()
         sys.exit(-1)
-       
+
     #loop to restart the optimization
-    restartAttempts=3
-    initOutlierRejection=True
-    removedOutlierCorners=list() 
+    restartAttempts = 3
+    initOutlierRejection = True
+    removedOutlierCorners = list()
+
+    info_csv = open("/tmp/kalibr_info.csv", "w")
+    info_csv.write("view_idx,view_ts,view_accepted,info,entropy\n")
+
     while True:
         try:
             #compute initial guesses for the baselines, intrinsics
             print("initializing initial guesses")
-            if len(cameraList)>1:
+            if len(cameraList) > 1:
                 baseline_guesses = graph.getInitialGuesses(cameraList)
             else:
-                baseline_guesses=[]
-                
-            if parsed.verbose and len(cameraList)>1:
+                baseline_guesses = []
+
+            if parsed.verbose and len(cameraList) > 1:
                 graph.plotGraph()
 
             for baseline_idx, baseline in enumerate(baseline_guesses):
-                print("initialized baseline between cam{0} and cam{1} to:".format(baseline_idx, baseline_idx+1))
+                print("initialized baseline between cam{0} and cam{1} to:".
+                      format(baseline_idx, baseline_idx + 1))
                 print(baseline.T())
-                
+
             for cam_idx, cam in enumerate(cameraList):
                 print("initialized cam{0} to:".format(cam_idx))
-                print("\t projection cam{0}: {1}".format(cam_idx, cam.geometry.projection().getParameters().flatten()))
-                print("\t distortion cam{0}: {1}".format(cam_idx, cam.geometry.projection().distortion().getParameters().flatten()))
-                
+                print("\t projection cam{0}: {1}".format(
+                    cam_idx,
+                    cam.geometry.projection().getParameters().flatten()))
+                print("\t distortion cam{0}: {1}".format(
+                    cam_idx,
+                    cam.geometry.projection().distortion().getParameters().
+                    flatten()))
 
             print("initializing calibrator")
-            calibrator = kcc.CameraCalibration(cameraList, baseline_guesses, verbose=parsed.verbose, useBlakeZissermanMest=parsed.doBlakeZisserman)
+            calibrator = kcc.CameraCalibration(
+                cameraList,
+                baseline_guesses,
+                verbose=parsed.verbose,
+                useBlakeZissermanMest=parsed.doBlakeZisserman)
             options = calibrator.estimator.getOptions()
             options.infoGainDelta = parsed.miTol
             options.checkValidity = True
@@ -242,15 +364,17 @@ def main():
             linearSolverOptions.epsSVD = 1e-6
             #linearSolverOptions.svdTol = 0.0 #TODO
             #linearSolverOptions.qrTol = 0.0
-            
+
             optimizerOptions = calibrator.estimator.getOptimizerOptions()
             optimizerOptions.maxIterations = 50
             optimizerOptions.verbose = parsed.verbose
             verbose = parsed.verbose
-        
+
             doPlot = parsed.plot
             if doPlot:
-                print("Plotting during calibration. Things may be very slow (but you might learn something).")
+                print(
+                    "Plotting during calibration. Things may be very slow (but you might learn something)."
+                )
 
             #shuffle the views
             timestamps = obsdb.getAllViewTimestamps()
@@ -260,188 +384,294 @@ def main():
             #process all target views
             print("starting calibration...")
             numViews = len(timestamps)
-            progress = sm.Progress2(numViews); progress.sample()
+            progress = sm.Progress2(numViews)
+            progress.sample()
             for view_id, timestamp in enumerate(timestamps):
-                
                 #add new batch problem
-                obs_tuple = obsdb.getAllObsAtTimestamp(timestamp)    
+                obs_tuple = obsdb.getAllObsAtTimestamp(timestamp)
                 est_baselines = list()
                 for bidx, baseline in enumerate(calibrator.baselines):
-                    est_baselines.append( sm.Transformation(baseline.T()) )
-                T_tc_guess = graph.getTargetPoseGuess(timestamp, cameraList, est_baselines)
-                               
+                    est_baselines.append(sm.Transformation(baseline.T()))
+                T_tc_guess = graph.getTargetPoseGuess(timestamp, cameraList,
+                                                      est_baselines)
+
                 success = calibrator.addTargetView(obs_tuple, T_tc_guess)
-                
+
                 #display process
-                if (verbose or (view_id % 25) == 0) and calibrator.estimator.getNumBatches()>0 and view_id>1:
+                if (
+                        verbose or (view_id % 25) == 0
+                ) and calibrator.estimator.getNumBatches() > 0 and view_id > 1:
                     print()
-                    print("------------------------------------------------------------------")
+                    print(
+                        "------------------------------------------------------------------"
+                    )
                     print()
-                    print("Processed {0} of {1} views with {2} views used".format(view_id+1, numViews, calibrator.estimator.getNumBatches()))
+                    print("Processed {0} of {1} views with {2} views used".
+                          format(view_id + 1, numViews,
+                                 calibrator.estimator.getNumBatches()))
                     print()
                     kcc.printParameters(calibrator)
                     print()
-                    print("------------------------------------------------------------------")
-                    
+                    print(
+                        "------------------------------------------------------------------"
+                    )
+
                 #calibration progress
                 progress.sample()
-                
+
                 #plot added views
                 if success and doPlot:
                     recent_view = calibrator.views[-1]
-                    cams_in_view = [obs_tuple[0] for obs_tuple in recent_view.rig_observations]
-                    plotter = PlotCollection.PlotCollection("Added view (stamp: {0})".format(timestamp))
+                    cams_in_view = [
+                        obs_tuple[0]
+                        for obs_tuple in recent_view.rig_observations
+                    ]
+                    plotter = PlotCollection.PlotCollection(
+                        "Added view (stamp: {0})".format(timestamp))
                     for cam_id in cams_in_view:
-                        fig=pl.figure(view_id*5000+cam_id)
-                        kcc.plotAllReprojectionErrors(calibrator, cam_id, fno=fig.number, noShow=True)                        
+                        fig = pl.figure(view_id * 5000 + cam_id)
+                        kcc.plotAllReprojectionErrors(calibrator,
+                                                      cam_id,
+                                                      fno=fig.number,
+                                                      noShow=True)
                         plotter.add_figure("cam{0}".format(cam_id), fig)
-                    plotter.show()   
-                
+                    plotter.show()
+
                 # Look for outliers
-                runEndFiltering = view_id==(len(timestamps)-1) and parsed.allowEndFiltering # run another filtering step at the end (over all batches)
+                runEndFiltering = view_id == (
+                    len(timestamps) - 1
+                ) and parsed.allowEndFiltering  # run another filtering step at the end (over all batches)
                 numActiveBatches = calibrator.estimator.getNumBatches()
-                if ((success and numActiveBatches>parsed.minViewOutlier*numCams) or (runEndFiltering and numActiveBatches>parsed.minViewOutlier*numCams)) and parsed.removeOutliers: 
-                    #create the list of the batches to check               
+                if ((success
+                     and numActiveBatches > parsed.minViewOutlier * numCams) or
+                    (runEndFiltering
+                     and numActiveBatches > parsed.minViewOutlier * numCams)
+                    ) and parsed.removeOutliers:
+                    #create the list of the batches to check
                     if initOutlierRejection:
                         #check all views after the min. number of batches has been reached
-                        batches_to_check=list(range(0, calibrator.estimator.getNumBatches()))
-                        print();print()
+                        batches_to_check = list(
+                            range(0, calibrator.estimator.getNumBatches()))
+                        print()
+                        print()
                         print("Filtering outliers in all batches...")
-                        initOutlierRejection=False
-                        progress_filter = sm.Progress2(len(batches_to_check)); progress_filter.sample()
+                        initOutlierRejection = False
+                        progress_filter = sm.Progress2(len(batches_to_check))
+                        progress_filter.sample()
                     elif runEndFiltering:
                         #check all batches again after all views have been processed
-                        print();print()
-                        print("All views have been processed.\n\nStarting final outlier filtering...")
-                        batches_to_check=list(range(0, calibrator.estimator.getNumBatches()))
-                        progress_filter = sm.Progress2(len(batches_to_check)); progress_filter.sample()
+                        print()
+                        print()
+                        print(
+                            "All views have been processed.\n\nStarting final outlier filtering..."
+                        )
+                        batches_to_check = list(
+                            range(0, calibrator.estimator.getNumBatches()))
+                        progress_filter = sm.Progress2(len(batches_to_check))
+                        progress_filter.sample()
                     else:
                         #only check most recent view
-                        batches_to_check = [ calibrator.estimator.getNumBatches()-1 ]
-                    
+                        batches_to_check = [
+                            calibrator.estimator.getNumBatches() - 1
+                        ]
+
                     #now check all the specified batches
                     batches_to_check.sort()
                     batches_to_check.reverse()
                     for batch_id in batches_to_check:
-                        
+
                         #check all cameras in this batch
-                        cornerRemovalList_allCams=list()
-                        camerasInBatch = list(calibrator.views[batch_id].rerrs.keys())
+                        cornerRemovalList_allCams = list()
+                        camerasInBatch = list(
+                            calibrator.views[batch_id].rerrs.keys())
                         for cidx in camerasInBatch:
-                            
+
                             #calculate the reprojection errors statistics
-                            corners, reprojs, rerrs = kcc.getReprojectionErrors(calibrator, cidx)        
+                            corners, reprojs, rerrs = kcc.getReprojectionErrors(
+                                calibrator, cidx)
                             me, se = kcc.getReprojectionErrorStatistics(rerrs)
-                            se_threshold = 4.0*se #TODO: find good value 
+                            se_threshold = 4.0 * se  #TODO: find good value
 
                             #select corners to remove
-                            cornerRemovalList=list()
+                            cornerRemovalList = list()
                             for pidx, reproj in enumerate(rerrs[batch_id]):
-                                if (not np.all(reproj==np.array([None,None]))) and (abs(reproj[0]) > se_threshold[0] or abs(reproj[1]) > se_threshold[1]):
+                                if (not np.all(
+                                        reproj == np.array([None, None]))
+                                    ) and (abs(reproj[0]) > se_threshold[0] or
+                                           abs(reproj[1]) > se_threshold[1]):
                                     cornerRemovalList.append(pidx)
-                                    
+
                                     #display the corners info
                                     if parsed.verbose or parsed.doPlotOutliers:
-                                        sm.logInfo( "Outlier detected on view {4} with idx {5} (rerr=({0}, {1}) > ({2},{3}) )".format(reproj[0], reproj[1], se_threshold[0], se_threshold[1], view_id, pidx))
-                                        sm.logInfo( "Predicted: {0}".format(calibrator.views[batch_id].rerrs[cidx][pidx].getPredictedMeasurement()) )
-                                        sm.logInfo( "Measured: {0}".format(calibrator.views[batch_id].rerrs[cidx][pidx].getMeasurement()) )
+                                        sm.logInfo(
+                                            "Outlier detected on view {4} with idx {5} (rerr=({0}, {1}) > ({2},{3}) )"
+                                            .format(reproj[0], reproj[1],
+                                                    se_threshold[0],
+                                                    se_threshold[1], view_id,
+                                                    pidx))
+                                        sm.logInfo("Predicted: {0}".format(
+                                            calibrator.views[batch_id].
+                                            rerrs[cidx]
+                                            [pidx].getPredictedMeasurement()))
+                                        sm.logInfo("Measured: {0}".format(
+                                            calibrator.views[batch_id].rerrs[
+                                                cidx][pidx].getMeasurement()))
 
                                     #store the outlier corners for plotting
-                                    removedOutlierCorners.append( (cidx, calibrator.views[batch_id].rerrs[cidx][pidx].getMeasurement()) )
-                            
+                                    removedOutlierCorners.append(
+                                        (cidx,
+                                         calibrator.views[batch_id].rerrs[cidx]
+                                         [pidx].getMeasurement()))
+
                             #queue corners on this cam for removal
-                            cornerRemovalList_allCams.append( (cidx, cornerRemovalList) )
-                            
+                            cornerRemovalList_allCams.append(
+                                (cidx, cornerRemovalList))
+
                             #plot the observation with the outliers
-                            if len(cornerRemovalList)>0 and parsed.doPlotOutliers:                                
-                                for cam_id, obs in calibrator.views[batch_id].rig_observations:
-                                    if cam_id==cidx:
+                            if len(cornerRemovalList
+                                   ) > 0 and parsed.doPlotOutliers:
+                                for cam_id, obs in calibrator.views[
+                                        batch_id].rig_observations:
+                                    if cam_id == cidx:
                                         gridobs = obs
-                                fig=pl.figure(view_id*100+batch_id+cidx)                                
-                                kcc.plotCornersAndReprojection(gridobs, reprojs[batch_id], cornerlist=cornerRemovalList, 
-                                                               fno=fig.number, clearFigure=True, plotImage=True,
-                                                               title="Removing outliers in view {0} on cam {0}".format(view_id, cidx))
+                                fig = pl.figure(view_id * 100 + batch_id +
+                                                cidx)
+                                kcc.plotCornersAndReprojection(
+                                    gridobs,
+                                    reprojs[batch_id],
+                                    cornerlist=cornerRemovalList,
+                                    fno=fig.number,
+                                    clearFigure=True,
+                                    plotImage=True,
+                                    title=
+                                    "Removing outliers in view {0} on cam {0}".
+                                    format(view_id, cidx))
                                 pl.show()
-    
+
                         #remove the corners (if there are corners to be removed)
-                        removeCount = sum([len(removelist) for cidx, removelist in cornerRemovalList_allCams])
-                        if removeCount>0:
+                        removeCount = sum([
+                            len(removelist)
+                            for cidx, removelist in cornerRemovalList_allCams
+                        ])
+                        if removeCount > 0:
                             original_batch = calibrator.views[batch_id]
-                            new_batch = kcc.removeCornersFromBatch(original_batch, cornerRemovalList_allCams, useBlakeZissermanMest=parsed.doBlakeZisserman)
-                            
+                            new_batch = kcc.removeCornersFromBatch(
+                                original_batch,
+                                cornerRemovalList_allCams,
+                                useBlakeZissermanMest=parsed.doBlakeZisserman)
+
                             #replace the original batch with the corrected
-                            calibrator.estimator.removeBatch( calibrator.views[batch_id] )
+                            calibrator.estimator.removeBatch(
+                                calibrator.views[batch_id])
                             calibrator.views[batch_id] = new_batch
-                            rval = calibrator.estimator.addBatch( new_batch, False )
-                            
+                            rval = calibrator.estimator.addBatch(
+                                new_batch, False)
+
                             #queue the batch for removal if the corrected batch was rejected
                             if not rval.batchAccepted:
-                                sm.logDebug("corrected view rejected! removing from optimization...")
-                                calibrator.views.remove( calibrator.views[batch_id] )
-                            sm.logDebug("Removed {0} outlier corners on batch {1}".format(removeCount, batch_id))   
-                        
+                                sm.logDebug(
+                                    "corrected view rejected! removing from optimization..."
+                                )
+                                calibrator.views.remove(
+                                    calibrator.views[batch_id])
+                            sm.logDebug(
+                                "Removed {0} outlier corners on batch {1}".
+                                format(removeCount, batch_id))
+
                         #start and end filtering progress bar
-                        if len(batches_to_check)>1:
+                        if len(batches_to_check) > 1:
                             progress_filter.sample()
-                            
+
+                # Record information
+                covar = calibrator.estimator.getSigma2Theta()
+                det_covar = np.linalg.det(covar)
+                k = (2.0 * np.pi * np.exp(1.0))**22.0
+                entropy = 0.5 * np.log(k * det_covar)
+                info = -1.0 * calibrator.estimator.getSvLog2Sum()
+                info_gain = calibrator.estimator.getInformationGain()
+
+                info_csv.write(
+                    f"{view_id},{timestamp},{success:d},{info},{entropy}\n")
+                info_csv.flush()
+
             #final output
             print()
             print()
-            print("..................................................................")
+            print(
+                ".................................................................."
+            )
             print()
             print("Calibration complete.")
             print()
             if parsed.removeOutliers:
-                sm.logWarn("Removed {0} outlier corners.".format(len(removedOutlierCorners)) )             
+                sm.logWarn("Removed {0} outlier corners.".format(
+                    len(removedOutlierCorners)))
             print()
-            print("Processed {0} images with {1} images used".format(numViews, calibrator.estimator.getNumBatches()))
+            print("Processed {0} images with {1} images used".format(
+                numViews, calibrator.estimator.getNumBatches()))
             kcc.printParameters(calibrator)
-            
-            if parsed.verbose and len(calibrator.baselines)>1:
-                f=pl.figure(100006)
-                kcc.plotCameraRig(calibrator.baselines, fno=f.number, clearFigure=False)
+
+            if parsed.verbose and len(calibrator.baselines) > 1:
+                f = pl.figure(100006)
+                kcc.plotCameraRig(calibrator.baselines,
+                                  fno=f.number,
+                                  clearFigure=False)
                 pl.show()
-            
+
             #write to file
-            bagtag = parsed.bagfile.translate("<>:/\|?*").replace('.bag', '', 1)
+            bagtag = parsed.bagfile.translate("<>:/\|?*").replace(
+                '.bag', '', 1)
             resultFile = "camchain-" + bagtag + ".yaml"
             kcc.saveChainParametersYaml(calibrator, resultFile, graph)
             print("Results written to file: {0}".format(resultFile))
-            
+
             #save results to file
             resultFileTxt = "results-cam-" + bagtag + ".txt"
             kcc.saveResultTxt(calibrator, filename=resultFileTxt)
-            print("  Detailed results written to file: {0}".format(resultFileTxt))
-            
+            print("  Detailed results written to file: {0}".format(
+                resultFileTxt))
+
             #generate report
             reportFile = "report-cam-" + bagtag + ".pdf"
-            G=None; 
-            if numCams>1: 
-                G=graph
-            kcc.generateReport(calibrator, reportFile, showOnScreen=not parsed.dontShowReport, graph=G, removedOutlierCorners=removedOutlierCorners);
-            
+            G = None
+            if numCams > 1:
+                G = graph
+            kcc.generateReport(calibrator,
+                               reportFile,
+                               showOnScreen=not parsed.dontShowReport,
+                               graph=G,
+                               removedOutlierCorners=removedOutlierCorners)
+
         except kcc.OptimizationDiverged:
-            restartAttempts-=1
-            sm.logWarn("Optimization diverged possibly due to a bad initialization. (Do the models fit the lenses well?)")
-            
-            if restartAttempts==0:
+            restartAttempts -= 1
+            sm.logWarn(
+                "Optimization diverged possibly due to a bad initialization. (Do the models fit the lenses well?)"
+            )
+
+            if restartAttempts == 0:
                 sm.logError("Max. attemps reached... Giving up...")
                 break
             else:
-                sm.logWarn("Restarting for a new attempt...")    
-                
+                sm.logWarn("Restarting for a new attempt...")
+
                 #reinitialize the intrinsics
                 for cam_id, cam in enumerate(cameraList):
-                    print("Reinitialize the intrinsics for camera {0}".format(cam_id))
+                    print("Reinitialize the intrinsics for camera {0}".format(
+                        cam_id))
                     observations = obsdb.getAllObsCam(cam_id)
                     if not cam.initGeometryFromObservations(observations):
-                        raise RuntimeError("Could not re-initialize the intrinsics for camera with topic: {0}".format(topic))
-                    
-                    print("\tProjection initialized to: %s" % cam.geometry.projection().getParameters().flatten())
-                    print("\tDistortion initialized to: %s" % cam.geometry.projection().distortion().getParameters().flatten())
-                
+                        raise RuntimeError(
+                            "Could not re-initialize the intrinsics for camera with topic: {0}"
+                            .format(topic))
+
+                    print("\tProjection initialized to: %s" %
+                          cam.geometry.projection().getParameters().flatten())
+                    print("\tDistortion initialized to: %s" % cam.geometry.
+                          projection().distortion().getParameters().flatten())
+
         else:
-            break #normal exit
+            break  #normal exit
+
 
 if __name__ == "__main__":
     main()
diff --git a/aslam_offline_calibration/kalibr/python/kalibr_camera_calibration/CameraCalibrator.py b/aslam_offline_calibration/kalibr/python/kalibr_camera_calibration/CameraCalibrator.py
index 1736d69..9ae85eb 100644
--- a/aslam_offline_calibration/kalibr/python/kalibr_camera_calibration/CameraCalibrator.py
+++ b/aslam_offline_calibration/kalibr/python/kalibr_camera_calibration/CameraCalibrator.py
@@ -24,29 +24,42 @@ CALIBRATION_GROUP_ID = 0
 TRANSFORMATION_GROUP_ID = 1
 LANDMARK_GROUP_ID = 2
 
+
 class OptimizationDiverged(Exception):
     pass
 
+
 class CameraGeometry(object):
-    def __init__(self, cameraModel, targetConfig, dataset, geometry=None, verbose=False):
+    def __init__(self,
+                 cameraModel,
+                 targetConfig,
+                 dataset,
+                 geometry=None,
+                 verbose=False):
         self.dataset = dataset
-        
+
         self.model = cameraModel
         if geometry is None:
             self.geometry = cameraModel.geometry()
-        
+
         if not type(self.geometry) == cameraModel.geometry:
-            raise RuntimeError("The type of geometry passed in \"%s\" does not match the model type \"%s\"" % (type(geometry),type(cameraModel.geometry)))
-        
+            raise RuntimeError(
+                "The type of geometry passed in \"%s\" does not match the model type \"%s\""
+                % (type(geometry), type(cameraModel.geometry)))
+
         #create the design variables
         self.dv = cameraModel.designVariable(self.geometry)
         self.setDvActiveStatus(True, True, False)
         self.isGeometryInitialized = False
-        
+
         #create target detector
-        self.ctarget = TargetDetector(targetConfig, self.geometry, showCorners=verbose, showReproj=verbose)
+        self.ctarget = TargetDetector(targetConfig,
+                                      self.geometry,
+                                      showCorners=verbose,
+                                      showReproj=verbose)
 
-    def setDvActiveStatus(self, projectionActive, distortionActive, shutterActice):
+    def setDvActiveStatus(self, projectionActive, distortionActive,
+                          shutterActice):
         self.dv.projectionDesignVariable().setActive(projectionActive)
         self.dv.distortionDesignVariable().setActive(distortionActive)
         self.dv.shutterDesignVariable().setActive(shutterActice)
@@ -55,27 +68,41 @@ class CameraGeometry(object):
         #obtain focal length guess
         success = self.geometry.initializeIntrinsics(observations)
         if not success:
-            sm.logError("initialization of focal length for cam with topic {0} failed  ".format(self.dataset.topic))
-        
+            sm.logError(
+                "initialization of focal length for cam with topic {0} failed  "
+                .format(self.dataset.topic))
+
         #in case of an omni model, first optimize over intrinsics only
         #(--> catch most of the distortion with the projection model)
         if self.model == acvb.DistortedOmni:
-            success = kcc.calibrateIntrinsics(self, observations, distortionActive=False)
+            success = kcc.calibrateIntrinsics(self,
+                                              observations,
+                                              distortionActive=False)
             if not success:
-                sm.logError("initialization of intrinsics for cam with topic {0} failed  ".format(self.dataset.topic))
-        
-        #optimize for intrinsics & distortion    
+                sm.logError(
+                    "initialization of intrinsics for cam with topic {0} failed  "
+                    .format(self.dataset.topic))
+
+        #optimize for intrinsics & distortion
         success = kcc.calibrateIntrinsics(self, observations)
         if not success:
-            sm.logError("initialization of intrinsics for cam with topic {0} failed  ".format(self.dataset.topic))
-        
-        self.isGeometryInitialized = success        
+            sm.logError(
+                "initialization of intrinsics for cam with topic {0} failed  ".
+                format(self.dataset.topic))
+
+        self.isGeometryInitialized = success
         return success
 
+
 class TargetDetector(object):
-    def __init__(self, targetConfig, cameraGeometry, showCorners=False, showReproj=False, showOneStep=False):
+    def __init__(self,
+                 targetConfig,
+                 cameraGeometry,
+                 showCorners=False,
+                 showReproj=False,
+                 showOneStep=False):
         self.targetConfig = targetConfig
-        
+
         #initialize the calibration target
         targetParams = targetConfig.getTargetParams()
         targetType = targetConfig.getTargetType()
@@ -84,68 +111,75 @@ class TargetDetector(object):
             options = acv.CheckerboardOptions()
             options.filterQuads = True
             options.normalizeImage = True
-            options.useAdaptiveThreshold = True        
+            options.useAdaptiveThreshold = True
             options.performFastCheck = False
-            options.windowWidth = 5            
+            options.windowWidth = 5
             options.showExtractionVideo = showCorners
-            
-            self.grid = acv.GridCalibrationTargetCheckerboard(targetParams['targetRows'], 
-                                                              targetParams['targetCols'], 
-                                                              targetParams['rowSpacingMeters'], 
-                                                              targetParams['colSpacingMeters'], 
-                                                              options)
+
+            self.grid = acv.GridCalibrationTargetCheckerboard(
+                targetParams['targetRows'], targetParams['targetCols'],
+                targetParams['rowSpacingMeters'],
+                targetParams['colSpacingMeters'], options)
         elif targetType == 'circlegrid':
             options = acv.CirclegridOptions()
             options.showExtractionVideo = showCorners
             options.useAsymmetricCirclegrid = targetParams['asymmetricGrid']
-            
-            self.grid = acv.GridCalibrationTargetCirclegrid(targetParams['targetRows'],
-                                                           targetParams['targetCols'], 
-                                                           targetParams['spacingMeters'], 
-                                                           options)
-         
+
+            self.grid = acv.GridCalibrationTargetCirclegrid(
+                targetParams['targetRows'], targetParams['targetCols'],
+                targetParams['spacingMeters'], options)
+
         elif targetType == 'aprilgrid':
             options = acv_april.AprilgridOptions()
             #enforce more than one row --> pnp solution can be bad if all points are almost on a line...
-            options.minTagsForValidObs = int( np.max( [targetParams['tagRows'], targetParams['tagCols']] ) + 1 )
+            options.minTagsForValidObs = int(
+                np.max([targetParams['tagRows'], targetParams['tagCols']]) + 1)
             options.showExtractionVideo = showCorners
-            
-            self.grid = acv_april.GridCalibrationTargetAprilgrid(targetParams['tagRows'], 
-                                                                 targetParams['tagCols'], 
-                                                                 targetParams['tagSize'], 
-                                                                 targetParams['tagSpacing'], 
-                                                                 options)
+
+            self.grid = acv_april.GridCalibrationTargetAprilgrid(
+                targetParams['tagRows'], targetParams['tagCols'],
+                targetParams['tagSize'], targetParams['tagSpacing'], options)
         else:
             RuntimeError('Unknown calibration target type!')
 
-        options = acv.GridDetectorOptions() 
+        options = acv.GridDetectorOptions()
         options.imageStepping = showOneStep
         options.plotCornerReprojection = showReproj
         options.filterCornerOutliers = False
-        
+
         self.detector = acv.GridDetector(cameraGeometry, self.grid, options)
 
+
 class CalibrationTarget(object):
     def __init__(self, target, estimateLandmarks=False):
         self.target = target
         # Create design variables and expressions for all target points.
         P_t_dv = []
         P_t_ex = []
-        for i in range(0,self.target.size()):
-            p_t_dv = aopt.HomogeneousPointDv(sm.toHomogeneous(self.target.point(i)));
+        for i in range(0, self.target.size()):
+            p_t_dv = aopt.HomogeneousPointDv(
+                sm.toHomogeneous(self.target.point(i)))
             p_t_dv.setActive(estimateLandmarks)
             p_t_ex = p_t_dv.toExpression()
             P_t_dv.append(p_t_dv)
             P_t_ex.append(p_t_ex)
         self.P_t_dv = P_t_dv
         self.P_t_ex = P_t_ex
-    def getPoint(self,i):
+
+    def getPoint(self, i):
         return P_t_ex[i]
 
-class CalibrationTargetOptimizationProblem(ic.CalibrationOptimizationProblem):        
+
+class CalibrationTargetOptimizationProblem(ic.CalibrationOptimizationProblem):
     @classmethod
-    def fromTargetViewObservations(cls, cameras, target, baselines, T_tc_guess, rig_observations, useBlakeZissermanMest=True):
-        rval = CalibrationTargetOptimizationProblem()        
+    def fromTargetViewObservations(cls,
+                                   cameras,
+                                   target,
+                                   baselines,
+                                   T_tc_guess,
+                                   rig_observations,
+                                   useBlakeZissermanMest=True):
+        rval = CalibrationTargetOptimizationProblem()
 
         #store the arguements in case we want to rebuild a modified problem
         rval.cameras = cameras
@@ -153,128 +187,159 @@ class CalibrationTargetOptimizationProblem(ic.CalibrationOptimizationProblem):
         rval.baselines = baselines
         rval.T_tc_guess = T_tc_guess
         rval.rig_observations = rig_observations
-        
+
         # 1. Create a design variable for this pose
         T_target_camera = T_tc_guess
-        
+
         rval.dv_T_target_camera = aopt.TransformationDv(T_target_camera)
         for i in range(0, rval.dv_T_target_camera.numDesignVariables()):
-            rval.addDesignVariable( rval.dv_T_target_camera.getDesignVariable(i), TRANSFORMATION_GROUP_ID)
-        
+            rval.addDesignVariable(
+                rval.dv_T_target_camera.getDesignVariable(i),
+                TRANSFORMATION_GROUP_ID)
+
         #2. add all baselines DVs
         for baseline_dv in baselines:
             for i in range(0, baseline_dv.numDesignVariables()):
-                rval.addDesignVariable(baseline_dv.getDesignVariable(i), CALIBRATION_GROUP_ID)
-        
+                rval.addDesignVariable(baseline_dv.getDesignVariable(i),
+                                       CALIBRATION_GROUP_ID)
+
         #3. add landmark DVs
         for p in target.P_t_dv:
-            rval.addDesignVariable(p,LANDMARK_GROUP_ID)
-        
+            rval.addDesignVariable(p, LANDMARK_GROUP_ID)
+
         #4. add camera DVs
         for camera in cameras:
             if not camera.isGeometryInitialized:
-                raise RuntimeError('The camera geometry is not initialized. Please initialize with initGeometry() or initGeometryFromDataset()')
+                raise RuntimeError(
+                    'The camera geometry is not initialized. Please initialize with initGeometry() or initGeometryFromDataset()'
+                )
             camera.setDvActiveStatus(True, True, False)
-            rval.addDesignVariable(camera.dv.distortionDesignVariable(), CALIBRATION_GROUP_ID)
-            rval.addDesignVariable(camera.dv.projectionDesignVariable(), CALIBRATION_GROUP_ID)
-            rval.addDesignVariable(camera.dv.shutterDesignVariable(), CALIBRATION_GROUP_ID)
-        
+            rval.addDesignVariable(camera.dv.distortionDesignVariable(),
+                                   CALIBRATION_GROUP_ID)
+            rval.addDesignVariable(camera.dv.projectionDesignVariable(),
+                                   CALIBRATION_GROUP_ID)
+            rval.addDesignVariable(camera.dv.shutterDesignVariable(),
+                                   CALIBRATION_GROUP_ID)
+
         #4.add all observations for this view
         cams_in_view = set()
-        rval.rerrs=dict()
-        rerr_cnt=0
+        rval.rerrs = dict()
+        rerr_cnt = 0
         for cam_id, obs in rig_observations:
             camera = cameras[cam_id]
             cams_in_view.add(cam_id)
-            
+
             #add reprojection errors
-            #build baseline chain (target->cam0->baselines->camN)                
+            #build baseline chain (target->cam0->baselines->camN)
             T_cam0_target = rval.dv_T_target_camera.expression.inverse()
             T_camN_calib = T_cam0_target
             for idx in range(0, cam_id):
-                T_camN_calib =  baselines[idx].toExpression() * T_camN_calib
-            
+                T_camN_calib = baselines[idx].toExpression() * T_camN_calib
+
             # \todo pass in the detector uncertainty somehow.
             cornerUncertainty = 1.0
             R = np.eye(2) * cornerUncertainty * cornerUncertainty
             invR = np.linalg.inv(R)
-            
+
             rval.rerrs[cam_id] = list()
-            for i in range(0,len(target.P_t_ex)):
+            for i in range(0, len(target.P_t_ex)):
                 p_target = target.P_t_ex[i]
                 valid, y = obs.imagePoint(i)
                 if valid:
-                    rerr_cnt+=1
+                    rerr_cnt += 1
                     # Create an error term.
-                    rerr = camera.model.reprojectionError(y, invR, T_camN_calib * p_target, camera.dv)
+                    rerr = camera.model.reprojectionError(
+                        y, invR, T_camN_calib * p_target, camera.dv)
                     rerr.idx = i
-                    
+
                     #add blake-zisserman mest
                     if useBlakeZissermanMest:
-                        mest = aopt.BlakeZissermanMEstimator( 2.0 )
+                        mest = aopt.BlakeZissermanMEstimator(2.0)
                         rerr.setMEstimatorPolicy(mest)
                     rval.addErrorTerm(rerr)
                     rval.rerrs[cam_id].append(rerr)
                 else:
                     rval.rerrs[cam_id].append(None)
 
-        sm.logDebug("Adding a view with {0} cameras and {1} error terms".format(len(cams_in_view), rerr_cnt))
+        sm.logDebug(
+            "Adding a view with {0} cameras and {1} error terms".format(
+                len(cams_in_view), rerr_cnt))
         return rval
 
-def removeCornersFromBatch(batch, camId_cornerIdList_tuples, useBlakeZissermanMest=True):
+
+def removeCornersFromBatch(batch,
+                           camId_cornerIdList_tuples,
+                           useBlakeZissermanMest=True):
     #translate (camid,obs) tuple to dict
-    obsdict=dict()
+    obsdict = dict()
     for cidx, obs in batch.rig_observations:
-        obsdict[cidx]=obs
-       
+        obsdict[cidx] = obs
+
     #disable the corners
-    hasCornerRemoved=False
+    hasCornerRemoved = False
     for cidx, removelist in camId_cornerIdList_tuples:
-        for corner_id in removelist: 
+        for corner_id in removelist:
             obsdict[cidx].removeImagePoint(corner_id)
-            hasCornerRemoved=True
+            hasCornerRemoved = True
     assert hasCornerRemoved, "need to remove at least one corner..."
-    
+
     #rebuild problem
-    new_problem = CalibrationTargetOptimizationProblem.fromTargetViewObservations(batch.cameras, 
-                                                                                  batch.target, 
-                                                                                  batch.baselines, 
-                                                                                  batch.T_tc_guess, 
-                                                                                  batch.rig_observations,
-                                                                                  useBlakeZissermanMest=useBlakeZissermanMest)
+    new_problem = CalibrationTargetOptimizationProblem.fromTargetViewObservations(
+        batch.cameras,
+        batch.target,
+        batch.baselines,
+        batch.T_tc_guess,
+        batch.rig_observations,
+        useBlakeZissermanMest=useBlakeZissermanMest)
 
     return new_problem
-        
+
+
 class CameraCalibration(object):
-    def __init__(self, cameras, baseline_guesses, estimateLandmarks=False, verbose=False, useBlakeZissermanMest=True):
+    def __init__(self,
+                 cameras,
+                 baseline_guesses,
+                 estimateLandmarks=False,
+                 verbose=False,
+                 useBlakeZissermanMest=True):
         self.cameras = cameras
         self.useBlakeZissermanMest = useBlakeZissermanMest
         #create the incremental estimator
         self.estimator = ic.IncrementalEstimator(CALIBRATION_GROUP_ID)
         self.linearSolverOptions = self.estimator.getLinearSolverOptions()
         self.optimizerOptions = self.estimator.getOptimizerOptions()
-        self.target = CalibrationTarget(cameras[0].ctarget.detector.target(), estimateLandmarks=estimateLandmarks)
+        self.target = CalibrationTarget(cameras[0].ctarget.detector.target(),
+                                        estimateLandmarks=estimateLandmarks)
         self.initializeBaselineDVs(baseline_guesses)
         #storage for the used views
         self.views = list()
-        
+
     def initializeBaselineDVs(self, baseline_guesses):
         self.baselines = list()
-        for baseline_idx in range(0, len(self.cameras)-1): 
-            self.baselines.append( aopt.TransformationDv(baseline_guesses[baseline_idx]) )
-            
+        for baseline_idx in range(0, len(self.cameras) - 1):
+            self.baselines.append(
+                aopt.TransformationDv(baseline_guesses[baseline_idx]))
+
     def getBaseline(self, i):
         return self.baselines[i]
-    
+
     def addTargetView(self, rig_observations, T_tc_guess, force=False):
-        #create the problem for this batch and try to add it 
-        batch_problem = CalibrationTargetOptimizationProblem.fromTargetViewObservations(self.cameras, self.target, self.baselines, T_tc_guess, rig_observations, useBlakeZissermanMest=self.useBlakeZissermanMest)
-        self.estimator_return_value = self.estimator.addBatch(batch_problem, force)
-        
+        #create the problem for this batch and try to add it
+        batch_problem = CalibrationTargetOptimizationProblem.fromTargetViewObservations(
+            self.cameras,
+            self.target,
+            self.baselines,
+            T_tc_guess,
+            rig_observations,
+            useBlakeZissermanMest=self.useBlakeZissermanMest)
+        self.estimator_return_value = self.estimator.addBatch(
+            batch_problem, force)
+        # print(f"covar_det: {self.estimator_return_value.margCovarDet}")
+
         if self.estimator_return_value.numIterations >= self.optimizerOptions.maxIterations:
             sm.logError("Did not converge in maxIterations... restarting...")
             raise OptimizationDiverged
-        
+
         success = self.estimator_return_value.batchAccepted
         if success:
             sm.logDebug("The estimator accepted this batch")
@@ -282,25 +347,28 @@ class CameraCalibration(object):
         else:
             sm.logDebug("The estimator did not accept this batch")
         return success
-    
-    
+
+
 def normalize(v):
     return v / np.linalg.norm(v)
 
+
 def getImageCenterRay(cself, cam_id):
     # Get the ray of the image center
     geometry = cself.cameras[cam_id].geometry
     projection = geometry.projection()
-    yc = np.array( [ projection.cu(), projection.cv() ] )
+    yc = np.array([projection.cu(), projection.cv()])
     vc = normalize(geometry.keypointToEuclidean(yc))
-    return vc;
+    return vc
+
 
 class pointStatistics(object):
     pass
 
-def getPointStatistics(cself,view_id,cam_id,pidx):
+
+def getPointStatistics(cself, view_id, cam_id, pidx):
     view = cself.views[view_id]
-    
+
     #check if the given camera sees the target in the given view (and get the obs)
     #view.rig_observations = list of tuples (cam_id, obs)
     cams_in_view = [obs_tuple[0] for obs_tuple in view.rig_observations]
@@ -308,13 +376,15 @@ def getPointStatistics(cself,view_id,cam_id,pidx):
         rval = pointStatistics()
         rval.valid = False
         return rval
-    obs = view.rig_observations[ cams_in_view.index(cam_id) ][1]
-    
+    obs = view.rig_observations[cams_in_view.index(cam_id)][1]
+
     vc = getImageCenterRay(cself, cam_id)
-    z = np.array([0,0,1])
-    dz = np.dot(z,vc)
+    z = np.array([0, 0, 1])
+    dz = np.dot(z, vc)
     if np.abs(dz - 1.0) > 1e-3:
-        print("The point statistics are only valid if the camera points down the z axis. This camera has the image center: [%f, %f, %f]" % (z[0],z[1],z[2]))
+        print(
+            "The point statistics are only valid if the camera points down the z axis. This camera has the image center: [%f, %f, %f]"
+            % (z[0], z[1], z[2]))
     valid, y = obs.imagePoint(pidx)
     geometry = cself.cameras[cam_id].geometry
     rerr = None
@@ -323,12 +393,12 @@ def getPointStatistics(cself,view_id,cam_id,pidx):
     polarAngle = None
     squaredError = None
     e = None
-    
+
     if valid:
         #translate point index to error term index (pidx!=eidx if not all points are observed!)
         pidx_observed = obs.getCornersIdx()
-        eidx=list(pidx_observed).index(pidx)
-    
+        eidx = list(pidx_observed).index(pidx)
+
         rerr = view.errorTerm(eidx)
         e = rerr.error()
         yhat = y - e
@@ -336,7 +406,7 @@ def getPointStatistics(cself,view_id,cam_id,pidx):
         # Note, these calculations assume that the camera point
         # down the z-axis. If this is wrong...this is bad.
         polarAngle = math.acos(v[2])
-        azumithalAngle = math.atan2(v[1],v[0])
+        azumithalAngle = math.atan2(v[1], v[0])
         # Make sure to recompute the error just in case
         # The point has been updated
         rerr.evaluateError()
@@ -353,55 +423,61 @@ def getPointStatistics(cself,view_id,cam_id,pidx):
     rval.squaredError = squaredError
     rval.e = e
     return rval
-    
+
+
 def getReprojectionErrorStatistics(all_rerrs):
     """
     usage:  all_corners, all_reprojections, all_reprojection_errs = getReprojectionErrors(calibrator, 0)
             mean, std = getReprojectionErrorStatistics(all_reprojections)
     """
-    if not len(all_rerrs)>0:
+    if not len(all_rerrs) > 0:
         raise RuntimeError("rerrs has invalid dimension")
 
-    gc.disable() #append speed up
-    rerr_matrix=list();
+    gc.disable()  #append speed up
+    rerr_matrix = list()
     for view_id, view_rerrs in enumerate(all_rerrs):
-        if view_rerrs is not None: #if cam sees target in this view
+        if view_rerrs is not None:  #if cam sees target in this view
             for rerr in view_rerrs:
-                if not (rerr==np.array([None,None])).all(): #if corner was observed
+                if not (rerr == np.array([None, None
+                                          ])).all():  #if corner was observed
                     rerr_matrix.append(rerr)
-    
-    
+
     rerr_matrix = np.array(rerr_matrix)
     gc.enable()
-    
+
     mean = np.mean(rerr_matrix, 0, dtype=np.float)
     std = np.std(rerr_matrix, 0, dtype=np.float)
- 
+
     return mean, std
 
+
 #return a list (views) of a list (reprojection errors) for a cam
 def getReprojectionErrors(cself, cam_id):
-    all_corners = list(); all_reprojections = list(); all_reprojection_errs =list()
-    
-    gc.disable() #append speed up
+    all_corners = list()
+    all_reprojections = list()
+    all_reprojection_errs = list()
+
+    gc.disable()  #append speed up
     for view_id, view in enumerate(cself.views):
         if cam_id in list(view.rerrs.keys()):
-            view_corners=list(); view_reprojections=list(); view_reprojection_errs=list()
+            view_corners = list()
+            view_reprojections = list()
+            view_reprojection_errs = list()
             for rerr in view.rerrs[cam_id]:
                 #add if the corners was observed
                 if rerr is not None:
                     corner = rerr.getMeasurement()
                     reprojection = rerr.getPredictedMeasurement()
-                    err = corner-reprojection
+                    err = corner - reprojection
                 else:
                     corner = np.array([None, None])
                     reprojection = np.array([None, None])
                     err = np.array([None, None])
-                    
+
                 view_corners.append(corner)
                 view_reprojections.append(reprojection)
                 view_reprojection_errs.append(err)
-                    
+
             all_corners.append(np.array(view_corners))
             all_reprojections.append(np.array(view_reprojections))
             all_reprojection_errs.append(np.array(view_reprojection_errs))
@@ -413,140 +489,184 @@ def getReprojectionErrors(cself, cam_id):
 
     gc.enable()
     return all_corners, all_reprojections, all_reprojection_errs
-  
+
 
 #get statistics for one cam over all points
 def getAllPointStatistics(cself, cam_id):
-    gc.disable() #gc slows down appends... disable it temporarily
+    gc.disable()  #gc slows down appends... disable it temporarily
     stats = []
-    for view_id in range(0,len(cself.views)):
-        for p_idx in range(0,cself.target.target.size()):
-            stat = getPointStatistics(cself,view_id,cam_id,p_idx)
+    for view_id in range(0, len(cself.views)):
+        for p_idx in range(0, cself.target.target.size()):
+            stat = getPointStatistics(cself, view_id, cam_id, p_idx)
             if stat.valid:
                 stats.append(stat)
     gc.enable()
     return stats
 
-def plotPolarError(cself, cam_id, fno=1, clearFigure=True, stats=None, noShow=False, title=""):
+
+def plotPolarError(cself,
+                   cam_id,
+                   fno=1,
+                   clearFigure=True,
+                   stats=None,
+                   noShow=False,
+                   title=""):
     if stats is None:
         stats = getAllPointStatistics(cself, cam_id)
-    angleError = np.array([ [ np.degrees(s.polarAngle), math.sqrt(s.squaredError)] for s in stats ])
+    angleError = np.array(
+        [[np.degrees(s.polarAngle),
+          math.sqrt(s.squaredError)] for s in stats])
     # sort by polar angle
-    sae = angleError[ angleError[:,0].argsort() ]
-    
+    sae = angleError[angleError[:, 0].argsort()]
+
     # Now plot
     f = pl.figure(fno)
     if clearFigure:
         f.clf()
     f.suptitle(title)
-        
+
     pl.subplot(121)
-    pl.plot(sae[:,0],sae[:,1],'bx-')
+    pl.plot(sae[:, 0], sae[:, 1], 'bx-')
     pl.grid('on')
     pl.xlabel('polar angle (deg)')
     pl.ylabel('reprojection error (pixels)')
     pl.subplot(122)
-    pl.hist(sae[:,0])
+    pl.hist(sae[:, 0])
     pl.grid('on')
     pl.xlabel('polar angle (deg)')
     pl.ylabel('count')
     if not noShow:
         pl.show()
 
-def plotAzumithalError(cself, cam_id, fno=1, clearFigure=True, stats=None, noShow=False, title=""):
+
+def plotAzumithalError(cself,
+                       cam_id,
+                       fno=1,
+                       clearFigure=True,
+                       stats=None,
+                       noShow=False,
+                       title=""):
     if stats is None:
         stats = getAllPointStatistics(cself, cam_id)
-    angleError = np.array([ [ np.degrees(s.azumithalAngle), math.sqrt(s.squaredError)] for s in stats ])
+    angleError = np.array(
+        [[np.degrees(s.azumithalAngle),
+          math.sqrt(s.squaredError)] for s in stats])
     # sort by azumithal angle
-    sae = angleError[ angleError[:,0].argsort() ]
+    sae = angleError[angleError[:, 0].argsort()]
     # Now plot
     f = pl.figure(fno)
     if clearFigure:
         f.clf()
     f.suptitle(title)
-    
+
     pl.subplot(121)
-    pl.plot(sae[:,0],sae[:,1],'bx-')
+    pl.plot(sae[:, 0], sae[:, 1], 'bx-')
     pl.grid('on')
     pl.xlabel('azumithal angle (deg)')
     pl.ylabel('reprojection error (pixels)')
     pl.subplot(122)
-    pl.hist(sae[:,0])
+    pl.hist(sae[:, 0])
     pl.grid('on')
     pl.xlabel('azumithal angle (deg)')
     pl.ylabel('count')
     if not noShow:
         pl.show()
 
-def plotAllReprojectionErrors(cself, cam_id, fno=1, noShow=False, clearFigure=True, title=""):
+
+def plotAllReprojectionErrors(cself,
+                              cam_id,
+                              fno=1,
+                              noShow=False,
+                              clearFigure=True,
+                              title=""):
     # left: observations and projecitons
     # right: scatterplot of reprojection errors
     all_corners, reprojections, rerrs_xy = getReprojectionErrors(cself, cam_id)
-    resolution = (cself.cameras[cam_id].geometry.projection().ru(), cself.cameras[cam_id].geometry.projection().rv())
+    resolution = (cself.cameras[cam_id].geometry.projection().ru(),
+                  cself.cameras[cam_id].geometry.projection().rv())
 
     #create figure
     f = pl.figure(fno)
-    if clearFigure:    
+    if clearFigure:
         f.clf()
     f.suptitle(title)
-    
-    values = np.arange(len(cself.views))/np.double(len(cself.views))
-    cmap = pl.cm.jet(values,alpha=0.5)
-    
+
+    values = np.arange(len(cself.views)) / np.double(len(cself.views))
+    cmap = pl.cm.jet(values, alpha=0.5)
+
     #detected corners plot
-    a=pl.subplot(121)
+    a = pl.subplot(121)
     for view_id, corners in enumerate(all_corners):
-        if corners is not None: #if this camerea sees the target in this view
-            color = cmap[view_id,:]
-            pl.plot(corners[:,0], corners[:,1],'o-', mfc=color, c=color, mec=color)
+        if corners is not None:  #if this camerea sees the target in this view
+            color = cmap[view_id, :]
+            pl.plot(corners[:, 0],
+                    corners[:, 1],
+                    'o-',
+                    mfc=color,
+                    c=color,
+                    mec=color)
 
     #add an empty image to force the aspect ratio
-    I=np.zeros((resolution[1], resolution[0]))
+    I = np.zeros((resolution[1], resolution[0]))
     pl.imshow(I, cmap='Greys')
 
     #reprojection errors scatter plot
     sub = pl.subplot(122)
     for view_id, rerrs in enumerate(rerrs_xy):
-        if rerrs is not None: #if this camerea sees the target in this view
-            color = cmap[view_id,:]
-            pl.plot(rerrs[:,0], rerrs[:,1], 'x', lw=3, mew=3, color=color)
+        if rerrs is not None:  #if this camerea sees the target in this view
+            color = cmap[view_id, :]
+            pl.plot(rerrs[:, 0], rerrs[:, 1], 'x', lw=3, mew=3, color=color)
 
     pl.axis('equal')
     pl.grid('on')
     pl.xlabel('error x (pix)')
     pl.ylabel('error y (pix)')
 
-    SM = pl.cm.ScalarMappable(pl.cm.colors.Normalize(0.0,len(cself.views)), pl.cm.jet)
-    SM.set_array(np.arange(len(cself.views)));
+    SM = pl.cm.ScalarMappable(pl.cm.colors.Normalize(0.0, len(cself.views)),
+                              pl.cm.jet)
+    SM.set_array(np.arange(len(cself.views)))
     cb = pl.colorbar(SM)
     cb.set_label('image index')
     if not noShow:
         pl.show()
 
-def plotCornersAndReprojection(gridobs, reprojs, fno=1, cornerlist=None, clearFigure=True, plotImage=True, color=None, title=""):
+
+def plotCornersAndReprojection(gridobs,
+                               reprojs,
+                               fno=1,
+                               cornerlist=None,
+                               clearFigure=True,
+                               plotImage=True,
+                               color=None,
+                               title=""):
     #create figure
     f = pl.figure(fno)
-    if clearFigure:    
+    if clearFigure:
         f.clf()
     f.suptitle(title)
-    
-    plotCorners(gridobs, fno=fno, clearFigure=False, plotImage=True, cornerlist=cornerlist)
-    
+
+    plotCorners(gridobs,
+                fno=fno,
+                clearFigure=False,
+                plotImage=True,
+                cornerlist=cornerlist)
+
     #plot reprojection
     if color is None:
-        color = [1.0,0.0,0.0,0.5]
-        
+        color = [1.0, 0.0, 0.0, 0.5]
+
     # Get the reprojections:
     for pidx, reproj in enumerate(reprojs):
         if (cornerlist is not None) and (pidx in cornerlist):
-            if (not np.all(reproj==np.array([None,None]))):
+            if (not np.all(reproj == np.array([None, None]))):
                 pl.plot(reproj[0], reproj[1], 'x', lw=3, mew=3, color=color)
 
-    pl.xlim([0,gridobs.imCols()])
-    pl.ylim([gridobs.imRows(),0])
+    pl.xlim([0, gridobs.imCols()])
+    pl.ylim([gridobs.imRows(), 0])
     if clearFigure:
         pl.legend(['observation', 'reprojection'])
-        
+
+
 def recoverCovariance(cself):
     #Covariance ordering (=dv ordering)
     #ORDERING:   N=num cams
@@ -555,29 +675,30 @@ def recoverCovariance(cself):
     #                a) distortion --> 4
     #                b) projection --> omni:5, pinhole: 4
     #                c) shutter    --> 0
-    
+
     numCams = len(cself.cameras)
     est_stds = np.sqrt(cself.estimator.getSigma2Theta().diagonal())
 
     #split the variance for baselines
-    baseline_cov = est_stds[0:6*(numCams-1)]
-    std_baselines = np.array(baseline_cov).reshape(numCams-1,6).tolist()
-    
+    baseline_cov = est_stds[0:6 * (numCams - 1)]
+    std_baselines = np.array(baseline_cov).reshape(numCams - 1, 6).tolist()
+
     #split camera cov
-    cam_cov = est_stds[6*(numCams-1):]
+    cam_cov = est_stds[6 * (numCams - 1):]
     std_cameras = list()
-    
-    offset=0
+
+    offset = 0
     for cidx, cam in enumerate(cself.cameras):
         nt = cam.geometry.minimalDimensionsDistortion() +  \
              cam.geometry.minimalDimensionsProjection() +  \
              cam.geometry.minimalDimensionsShutter()
-        
-        std_cameras.append( cam_cov[offset:offset+nt].flatten().tolist() )
-        offset = offset+nt
-    
+
+        std_cameras.append(cam_cov[offset:offset + nt].flatten().tolist())
+        offset = offset + nt
+
     return std_baselines, std_cameras
 
+
 def printParameters(cself, dest=sys.stdout):
     #get the covariances
     std_baselines, std_cameras = recoverCovariance(cself)
@@ -589,27 +710,29 @@ def printParameters(cself, dest=sys.stdout):
         p = cam.geometry.projection().getParameters().flatten()
         dd = std_cameras[cidx][0:d.shape[0]]
         dp = std_cameras[cidx][d.shape[0]:]
-        print("\tcam{0} ({1}):".format(cidx, cam.dataset.topic), file=dest) 
-        print("\t type: %s" % ( type(cam.geometry) ), file=dest) 
+        print("\tcam{0} ({1}):".format(cidx, cam.dataset.topic), file=dest)
+        print("\t type: %s" % (type(cam.geometry)), file=dest)
         print("\t distortion: %s +- %s" % (d, np.array(dd)), file=dest)
         print("\t projection: %s +- %s" % (p, np.array(dp)), file=dest)
-        
+
         #reproj error statistics
-        corners, reprojs, rerrs = getReprojectionErrors(cself, cidx)        
-        if len(rerrs)>0:
+        corners, reprojs, rerrs = getReprojectionErrors(cself, cidx)
+        if len(rerrs) > 0:
             me, se = getReprojectionErrorStatistics(rerrs)
             try:
-              print("\t reprojection error: [%f, %f] +- [%f, %f]" % (me[0], me[1], se[0], se[1]), file=dest)
+                print("\t reprojection error: [%f, %f] +- [%f, %f]" %
+                      (me[0], me[1], se[0], se[1]),
+                      file=dest)
             except:
-              print("\t Failed printing the reprojection error.", file=dest)
+                print("\t Failed printing the reprojection error.", file=dest)
             print(file=dest)
 
     #print baselines
     for bidx, baseline in enumerate(cself.baselines):
-        T = sm.Transformation( baseline.T() )
+        T = sm.Transformation(baseline.T())
         dq = std_baselines[bidx][0:3]
         dt = std_baselines[bidx][3:6]
-        print("\tbaseline T_{1}_{0}:".format(bidx, bidx+1), file=dest) 
+        print("\tbaseline T_{1}_{0}:".format(bidx, bidx + 1), file=dest)
         print("\t q: %s +- %s" % (T.q(), np.array(dq)), file=dest)
         print("\t t: %s +- %s" % (T.t(), np.array(dt)), file=dest)
         print(file=dest)
@@ -618,58 +741,63 @@ def printParameters(cself, dest=sys.stdout):
 def printDebugEnd(cself):
     print()
     print()
-    
+
     for cidx, cam in enumerate(cself.cameras):
         print("cam{0}".format(cidx))
         print("----------")
         print()
         print()
-        
-        corners, reprojs, rerrs = getReprojectionErrors(cself, cidx)        
-        if len(rerrs)>0:
+
+        corners, reprojs, rerrs = getReprojectionErrors(cself, cidx)
+        if len(rerrs) > 0:
             me, se = getReprojectionErrorStatistics(rerrs)
             print(me[0])
             print(me[1])
             print(se[0])
             print(se[1])
-        
+
         print()
         p = cam.geometry.projection().getParameters().flatten()
         for temp in p:
             print(temp)
-        
+
         print()
         d = cam.geometry.projection().distortion().getParameters().flatten()
         for temp in d:
             print(temp)
-            
-        if cidx>0:
-            bidx=cidx-1
-            T = sm.Transformation( cself.baselines[bidx].T() )
+
+        if cidx > 0:
+            bidx = cidx - 1
+            T = sm.Transformation(cself.baselines[bidx].T())
             for temp in T.t():
                 print(temp)
-    
+
             for temp in T.q():
                 print(temp)
-    
+
     print()
     print()
 
+
 def saveChainParametersYaml(cself, resultFile, graph):
-    cameraModels = {acvb.DistortedPinhole: 'pinhole',
-                    acvb.EquidistantPinhole: 'pinhole',
-                    acvb.FovPinhole: 'pinhole',
-                    acvb.Omni: 'omni',
-                    acvb.DistortedOmni: 'omni',
-                    acvb.ExtendedUnified: 'eucm',
-                    acvb.DoubleSphere: 'ds'}
-    distortionModels = {acvb.DistortedPinhole: 'radtan',
-                        acvb.EquidistantPinhole: 'equidistant',
-                        acvb.FovPinhole: 'fov',
-                        acvb.Omni: 'none',
-                        acvb.DistortedOmni: 'radtan',
-                        acvb.ExtendedUnified: 'none',
-                        acvb.DoubleSphere: 'none'}
+    cameraModels = {
+        acvb.DistortedPinhole: 'pinhole',
+        acvb.EquidistantPinhole: 'pinhole',
+        acvb.FovPinhole: 'pinhole',
+        acvb.Omni: 'omni',
+        acvb.DistortedOmni: 'omni',
+        acvb.ExtendedUnified: 'eucm',
+        acvb.DoubleSphere: 'ds'
+    }
+    distortionModels = {
+        acvb.DistortedPinhole: 'radtan',
+        acvb.EquidistantPinhole: 'equidistant',
+        acvb.FovPinhole: 'fov',
+        acvb.Omni: 'none',
+        acvb.DistortedOmni: 'radtan',
+        acvb.ExtendedUnified: 'none',
+        acvb.DoubleSphere: 'none'
+    }
 
     chain = cr.CameraChainParameters(resultFile, createYaml=True)
     for cam_id, cam in enumerate(cself.cameras):
@@ -683,196 +811,239 @@ def saveChainParametersYaml(cself, resultFile, graph):
         #set the data
         P = cam.geometry.projection()
         if cameraModel == 'omni':
-            camParams.setIntrinsics(cameraModel, [P.xi(), P.fu(), P.fv(), P.cu(), P.cv()] )
+            camParams.setIntrinsics(
+                cameraModel,
+                [P.xi(), P.fu(), P.fv(),
+                 P.cu(), P.cv()])
         elif cameraModel == 'pinhole':
-            camParams.setIntrinsics(cameraModel, [P.fu(), P.fv(), P.cu(), P.cv()] )
+            camParams.setIntrinsics(
+                cameraModel,
+                [P.fu(), P.fv(), P.cu(), P.cv()])
         elif cameraModel == 'eucm':
-            camParams.setIntrinsics(cameraModel, [P.alpha(), P.beta(), P.fu(), P.fv(), P.cu(), P.cv()] )
+            camParams.setIntrinsics(
+                cameraModel,
+                [P.alpha(),
+                 P.beta(), P.fu(),
+                 P.fv(), P.cu(),
+                 P.cv()])
         elif cameraModel == 'ds':
-            camParams.setIntrinsics(cameraModel, [P.xi(), P.alpha(), P.fu(), P.fv(), P.cu(), P.cv()] )
+            camParams.setIntrinsics(
+                cameraModel,
+                [P.xi(), P.alpha(),
+                 P.fu(), P.fv(),
+                 P.cu(), P.cv()])
         else:
             raise RuntimeError("Invalid camera model {}.".format(cameraModel))
-        camParams.setResolution( [P.ru(), P.rv()] )
+        camParams.setResolution([P.ru(), P.rv()])
         dist_coeffs = P.distortion().getParameters().flatten()
-        camParams.setDistortion( distortionModel, dist_coeffs)
+        camParams.setDistortion(distortionModel, dist_coeffs)
 
         chain.addCameraAtEnd(camParams)
 
     for cam_id, cam in enumerate(cself.cameras):
         overlaps = graph.getCamOverlaps(cam_id)
         chain.setCamOverlaps(cam_id, overlaps)
-        
+
     #print all baselines in the camera chain
     for bidx, baseline_dv in enumerate(cself.baselines):
-        baseline = sm.Transformation( baseline_dv.T() )
-        camNr = bidx+1
+        baseline = sm.Transformation(baseline_dv.T())
+        camNr = bidx + 1
         chain.setExtrinsicsLastCamToHere(camNr, baseline)
 
     chain.writeYaml()
 
 
-def plotOutlierCorners(cself, removedOutlierCorners, fno=1, clearFigure=True, title=""):
+def plotOutlierCorners(cself,
+                       removedOutlierCorners,
+                       fno=1,
+                       clearFigure=True,
+                       title=""):
     #create figure
     f = pl.figure(fno)
-    if clearFigure:    
+    if clearFigure:
         f.clf()
     f.suptitle(title)
 
     #create subplot for each camera
     for cidx, camera in enumerate(cself.cameras):
         #extract corners for this cam
-        corners=list()
+        corners = list()
         for cam_id, removed_corners in removedOutlierCorners:
-            if cam_id==cidx:
+            if cam_id == cidx:
                 corners.append(removed_corners)
-        corners=np.array(corners)
-        
+        corners = np.array(corners)
+
         #plot
-        subplot_rows = np.ceil( np.sqrt(len(cself.cameras)) )
-        subplot_cols = np.ceil( np.sqrt(len(cself.cameras)) )
-        pl.subplot(subplot_rows, subplot_cols, cidx+1)
+        subplot_rows = np.ceil(np.sqrt(len(cself.cameras)))
+        subplot_cols = np.ceil(np.sqrt(len(cself.cameras)))
+        pl.subplot(subplot_rows, subplot_cols, cidx + 1)
         pl.title("cam{0}".format(cidx))
-            
-        if len(corners)>0:
-            pl.plot(corners[:,0], corners[:,1], 'rx')
-            
+
+        if len(corners) > 0:
+            pl.plot(corners[:, 0], corners[:, 1], 'rx')
+
         #add an empty image to force the aspect ratio
-        resolution = (camera.geometry.projection().ru(), camera.geometry.projection().rv())
-        I=np.zeros((resolution[1], resolution[0]))
+        resolution = (camera.geometry.projection().ru(),
+                      camera.geometry.projection().rv())
+        I = np.zeros((resolution[1], resolution[0]))
         pl.imshow(I, cmap='Greys')
-        
 
-def generateReport(cself, filename="report.pdf", showOnScreen=True, graph=None, removedOutlierCorners=None):
+
+def generateReport(cself,
+                   filename="report.pdf",
+                   showOnScreen=True,
+                   graph=None,
+                   removedOutlierCorners=None):
     #plotter
     plotter = PlotCollection.PlotCollection("Calibration report")
 
-    figs = list()    
+    figs = list()
     #plot graph
     if graph is not None:
-        f=pl.figure(1001)
-        title="Inter-camera observations graph (edge weight=#mutual obs.)";
+        f = pl.figure(1001)
+        title = "Inter-camera observations graph (edge weight=#mutual obs.)"
         graph.plotGraphPylab(fno=f.number, noShow=True, title=title)
         plotter.add_figure("Obs. graph", f)
         figs.append(f)
-        
+
     #rig geometry
-    if len(cself.cameras)>1:
-        f=pl.figure(1002)
-        title="camera system"
-        plotCameraRig(cself.baselines, fno=f.number, clearFigure=False, title=title)
+    if len(cself.cameras) > 1:
+        f = pl.figure(1002)
+        title = "camera system"
+        plotCameraRig(cself.baselines,
+                      fno=f.number,
+                      clearFigure=False,
+                      title=title)
         plotter.add_figure(title, f)
         figs.append(f)
-        
+
     #plot for each camera
     for cidx, cam in enumerate(cself.cameras):
-        f = pl.figure(cidx*10+1)
-        title="cam{0}: polar error".format(cidx)
+        f = pl.figure(cidx * 10 + 1)
+        title = "cam{0}: polar error".format(cidx)
         plotPolarError(cself, cidx, fno=f.number, noShow=True, title=title)
         plotter.add_figure(title, f)
         figs.append(f)
-        f = pl.figure(cidx*10+2)
-        title="cam{0}: azimutal error".format(cidx)
+        f = pl.figure(cidx * 10 + 2)
+        title = "cam{0}: azimutal error".format(cidx)
         plotAzumithalError(cself, cidx, fno=f.number, noShow=True, title=title)
         plotter.add_figure(title, f)
         figs.append(f)
-        f = pl.figure(cidx*10+3)
-        title="cam{0}: reprojection errors".format(cidx)
-        plotAllReprojectionErrors(cself, cidx, fno=f.number, noShow=True, title=title)
+        f = pl.figure(cidx * 10 + 3)
+        title = "cam{0}: reprojection errors".format(cidx)
+        plotAllReprojectionErrors(cself,
+                                  cidx,
+                                  fno=f.number,
+                                  noShow=True,
+                                  title=title)
         plotter.add_figure(title, f)
         figs.append(f)
-    
+
     #plot all removed outlier corners
     if removedOutlierCorners is not None:
         if len(removedOutlierCorners) > 0:
-            f=pl.figure(1003)
-            title="Location of removed outlier corners"
-            plotOutlierCorners(cself, removedOutlierCorners, fno=f.number, title=title)
+            f = pl.figure(1003)
+            title = "Location of removed outlier corners"
+            plotOutlierCorners(cself,
+                               removedOutlierCorners,
+                               fno=f.number,
+                               title=title)
             plotter.add_figure("Outlier corners", f)
             figs.append(f)
-            
+
     #save to pdf
-    pdf=PdfPages(filename)
+    pdf = PdfPages(filename)
     for fig in figs:
         pdf.savefig(fig)
     pdf.close()
     print("Report written to: {0}".format(filename))
-    
+
     if showOnScreen:
-        plotter.show()  
-    
-def plotCorners(gridobs, fno=1, cornerlist=None, clearFigure=True, plotImage=True, color=None, subplot=0):
+        plotter.show()
+
+
+def plotCorners(gridobs,
+                fno=1,
+                cornerlist=None,
+                clearFigure=True,
+                plotImage=True,
+                color=None,
+                subplot=0):
     if color is None:
-        color = [0,1,1,0.3];
+        color = [0, 1, 1, 0.3]
     f = pl.figure(fno)
-    if subplot>0:
+    if subplot > 0:
         pl.subplot(subplot)
     if clearFigure:
         f.clf()
     if plotImage:
         I = gridobs.getImage()
         if len(I.shape) == 2 and I.shape[0] > 0 and I.shape[1] > 0:
-            pl.imshow(I,cmap=pl.cm.gray)
+            pl.imshow(I, cmap=pl.cm.gray)
 
     #only plot certain corners as an option
     if cornerlist is not None:
-        P=list()
+        P = list()
         for pidx in cornerlist:
             valid, y = gridobs.imagePoint(pidx)
             if valid:
                 P.append(y)
             else:
-                print("Tried to plot unobserved corner")       
-        P=np.array(P)
+                print("Tried to plot unobserved corner")
+        P = np.array(P)
     else:
         #get all points
-        P=gridobs.getCornersImageFrame()
-    
-    pl.plot(P[:,0], P[:,1],'o-', mfc=color, c=color, mec=color)
-    pl.xlim([0,gridobs.imCols()])
-    pl.ylim([gridobs.imRows(),0])
+        P = gridobs.getCornersImageFrame()
+
+    pl.plot(P[:, 0], P[:, 1], 'o-', mfc=color, c=color, mec=color)
+    pl.xlim([0, gridobs.imCols()])
+    pl.ylim([gridobs.imRows(), 0])
+
 
 def plotCameraRig(baselines, fno=1, clearFigure=True, title=""):
     f = pl.figure(fno)
     if clearFigure:
         f.clf()
     f.suptitle(title)
-    
+
     #convet DVs to trafo
-    temp=list()
+    temp = list()
     for baseline in baselines:
         temp.append(sm.Transformation(baseline.T()))
-    baselines=temp
-        
+    baselines = temp
+
     #convert baselines to camera frames in coords of first camera
-    camera_frames=list()
-    camera_frames.append(sm.Transformation()) #first cam
+    camera_frames = list()
+    camera_frames.append(sm.Transformation())  #first cam
     for bidx, baseline in enumerate(baselines):
-        camera_frames.append( camera_frames[bidx]*baseline.inverse() )
-    
+        camera_frames.append(camera_frames[bidx] * baseline.inverse())
+
     #get the of the coord system (half the shortest baseline)
-    sizes=list()
+    sizes = list()
     for baseline in baselines:
-        sizes.append( np.linalg.norm(baseline.t()) )
-    size=0.5*np.min(sizes)
-    
+        sizes.append(np.linalg.norm(baseline.t()))
+    size = 0.5 * np.min(sizes)
+
     #plot each frame in coordinates of first camera
     a3d = f.add_subplot(111, projection='3d')
     for camera_frame in camera_frames:
         sm.plotCoordinateFrame(a3d, camera_frame.T(), size=size)
 
     #axis equal
-    box_sizes=list()
+    box_sizes = list()
     for camera_frame in camera_frames:
-        box_sizes.append( np.linalg.norm(camera_frame.t()) )
-    box_size=1.25*np.max(box_sizes)+size
-    
-    a3d.auto_scale_xyz([-box_size, box_size], [-box_size, box_size], [-box_size, box_size])
-   
+        box_sizes.append(np.linalg.norm(camera_frame.t()))
+    box_size = 1.25 * np.max(box_sizes) + size
+
+    a3d.auto_scale_xyz([-box_size, box_size], [-box_size, box_size],
+                       [-box_size, box_size])
+
+
 def saveResultTxt(cself, filename="camera_calibration_result.txt"):
-    f1=open(filename, 'w')
+    f1 = open(filename, 'w')
     print("Calibration results ", file=f1)
     print("====================", file=f1)
-    
+
     printParameters(cself, f1)
     print("", file=f1)
     print("", file=f1)
@@ -881,4 +1052,3 @@ def saveResultTxt(cself, filename="camera_calibration_result.txt"):
     print("", file=f1)
 
     cself.cameras[0].ctarget.targetConfig.printDetails(f1)
-    
